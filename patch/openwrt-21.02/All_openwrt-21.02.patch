--- a/target/linux/sunxi/config-5.4 2021-04-19 22:10:14.000000000 +0300
+++ b/target/linux/sunxi/config-5.4 2021-05-21 12:13:05.378889259 +0300
@@ -90,6 +90,7 @@
 CONFIG_CLK_SUNXI_PRCM_SUN6I=y
 CONFIG_CLK_SUNXI_PRCM_SUN8I=y
 CONFIG_CLK_SUNXI_PRCM_SUN9I=y
+CONFIG_CLOCK_THERMAL=y
 CONFIG_CLONE_BACKWARDS=y
 CONFIG_COMMON_CLK=y
 CONFIG_CONFIGFS_FS=y
@@ -133,6 +134,7 @@
 CONFIG_CRYPTO_CRC32=y
 CONFIG_CRYPTO_CRC32C=y
 CONFIG_CRYPTO_CRCT10DIF=y
+CONFIG_CRYPTO_CRCT10DIF_ARM_CE=y
 CONFIG_CRYPTO_DES=y
 CONFIG_CRYPTO_DEV_SUN4I_SS=y
 CONFIG_CRYPTO_DEV_SUN4I_SS_PRNG=y
@@ -303,6 +305,7 @@
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_INPUT=y
 CONFIG_INPUT_AXP20X_PEK=y
+CONFIG_INPUT_EVDEV=y
 CONFIG_INPUT_KEYBOARD=y
 CONFIG_INPUT_MOUSEDEV=y
 CONFIG_INPUT_MOUSEDEV_PSAUX=y
@@ -328,6 +331,7 @@
 CONFIG_LCD_PLATFORM=y
 CONFIG_LEDS_GPIO=y
 CONFIG_LIBFDT=y
+CONFIG_LIRC=y
 CONFIG_LOCK_DEBUGGING_SUPPORT=y
 CONFIG_LOCK_SPIN_ON_OWNER=y
 CONFIG_LOGO=y
@@ -443,6 +447,10 @@
 CONFIG_RATIONAL=y
 CONFIG_RCU_NEED_SEGCBLIST=y
 CONFIG_RCU_STALL_COMMON=y
+CONFIG_RC_CORE=y
+CONFIG_RC_DECODERS=y
+CONFIG_RC_DEVICES=y
+CONFIG_RC_MAP=y
 CONFIG_REALTEK_PHY=y
 CONFIG_REFCOUNT_FULL=y
 CONFIG_REGMAP=y
@@ -488,10 +496,11 @@
 CONFIG_SND_SIMPLE_CARD_UTILS=y
 CONFIG_SND_SOC=y
 CONFIG_SND_SOC_I2C_AND_SPI=y
-# CONFIG_SND_SUN4I_I2S is not set
-# CONFIG_SND_SUN4I_SPDIF is not set
-# CONFIG_SND_SUN8I_CODEC is not set
-# CONFIG_SND_SUN8I_CODEC_ANALOG is not set
+CONFIG_SND_SUN4I_CODEC=y
+CONFIG_SND_SUN8I_CODEC=y
+CONFIG_SND_SUN8I_CODEC_ANALOG=y
+CONFIG_SND_SUN4I_SPDIF=y
+CONFIG_SND_SUN4I_I2S=y
 CONFIG_SOUND=y
 CONFIG_SOUND_OSS_CORE=y
 CONFIG_SPARSE_IRQ=y
@@ -537,11 +546,19 @@
 CONFIG_SYS_SUPPORTS_HUGETLBFS=y
 CONFIG_TASKS_RCU=y
 CONFIG_THERMAL=y
-CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE=y
+# CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE is not set
 CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS=0
+CONFIG_THERMAL_GOV_BANG_BANG=y
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
 CONFIG_THERMAL_GOV_STEP_WISE=y
 CONFIG_THERMAL_HWMON=y
 CONFIG_THERMAL_OF=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_SUN8I_THS=y
+CONFIG_SUN4I_GPADC=y
+# CONFIG_SUN50I_H6_THS is not set
 CONFIG_TICK_CPU_ACCOUNTING=y
 CONFIG_TIMER_OF=y
 CONFIG_TIMER_PROBE=y
@@ -553,6 +570,7 @@
 CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
 CONFIG_UNINLINE_SPIN_UNLOCK=y
 CONFIG_USB=y
+CONFIG_USB_ACM=y
 CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
 CONFIG_USB_COMMON=y
 CONFIG_USB_DWC2=y
--- a/target/linux/sunxi/modules.mk	2021-04-19 22:10:14.000000000 +0300
+++ b/target/linux/sunxi/modules.mk	2021-05-08 21:04:39.775977117 +0300
@@ -23,15 +23,58 @@
 define KernelPackage/sunxi-ir
     SUBMENU:=$(OTHER_MENU)
     TITLE:=Sunxi SoC built-in IR support (A20)
-    DEPENDS:=@TARGET_sunxi +kmod-input-core
+    DEPENDS:=@TARGET_sunxi +kmod-input-core +v4l-utils +triggerhappy
     $(call AddDepends/rtc)
     KCONFIG:= \
 	CONFIG_MEDIA_SUPPORT=y \
 	CONFIG_MEDIA_RC_SUPPORT=y \
+	CONFIG_IR_SUNXI=m \
+	CONFIG_RC_CORE=m \
+	CONFIG_RC_DECODERS=y \
 	CONFIG_RC_DEVICES=y \
-	CONFIG_IR_SUNXI
-    FILES:=$(LINUX_DIR)/drivers/media/rc/sunxi-cir.ko
-    AUTOLOAD:=$(call AutoLoad,50,sunxi-cir)
+	CONFIG_RC_MAP=m \
+	CONFIG_IR_LIRC_CODEC=m \
+	CONFIG_BPF_LIRC_MODE2=y \
+	CONFIG_IR_NEC_DECODER=m \
+	CONFIG_IR_RC5_DECODER=m \
+	CONFIG_IR_RC6_DECODER=m \
+	CONFIG_IR_JVC_DECODER=m \
+	CONFIG_IR_SONY_DECODER=m \
+	CONFIG_IR_SANYO_DECODER=m \
+	CONFIG_IR_SHARP_DECODER=m \
+	CONFIG_IR_MCE_KBD_DECODER=m \
+	CONFIG_IR_XMP_DECODER=m \
+	CONFIG_IR_IMON_DECODER=m \
+	CONFIG_IR_RCMM_DECODER=n \
+	CONFIG_IR_IMON_RAW=m \
+	CONFIG_IR_SPI=m \
+	CONFIG_IR_PWM_TX=m \
+	CONFIG_IR_SERIAL=m \
+	CONFIG_IR_SERIAL_TRANSMITTER=y \
+	CONFIG_IR_SIR=m \
+	CONFIG_RC_XBOX_DVD=n \
+	CONFIG_IR_GPIO_TX=m
+    FILES:= \
+	$(LINUX_DIR)/drivers/media/rc/gpio-ir-tx.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-jvc-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-mce_kbd-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-nec-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-rc5-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-rc6-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-sanyo-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-sharp-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-sony-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-spi.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-xmp-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/pwm-ir-tx.ko \
+	$(LINUX_DIR)/drivers/media/rc/serial_ir.ko \
+	$(LINUX_DIR)/drivers/media/rc/sir_ir.ko \
+	$(LINUX_DIR)/drivers/media/rc/rc-core.ko \
+	$(LINUX_DIR)/drivers/media/rc/sunxi-cir.ko
+#	$(LINUX_DIR)/drivers/media/rc/keymaps/*.ko \
+#	$(LINUX_DIR)/drivers/media/rc/rc-core.ko \
+#	$(LINUX_DIR)/drivers/media/rc/lirc_dev.ko
+    AUTOLOAD:=$(call AutoLoad,80,sunxi-cir ir-nec-decoder)
 endef
 
 define KernelPackage/sunxi-ir/description
@@ -76,7 +119,7 @@
 endef
 
 define KernelPackage/sound-soc-sunxi/description
-  Kernel support for AllWinner built-in SoC audio
+  Kernel support for AllWinner built-in SoC audio sun4i-codec
 endef
 
 $(eval $(call KernelPackage,sound-soc-sunxi))
@@ -95,3 +138,123 @@
 endef
 
 $(eval $(call KernelPackage,sound-soc-sunxi-spdif))
+
+
+define KernelPackage/sound-soc-sun8i-codec
+  TITLE:=AllWinner SoC sound sun8i-codec
+  KCONFIG:=CONFIG_SND_SUN8I_CODEC
+  FILES:=$(LINUX_DIR)/sound/soc/sunxi/sun8i-codec.ko
+  AUTOLOAD:=$(call AutoLoad,65,sun8i-codec)
+  DEPENDS:=@TARGET_sunxi +kmod-sound-soc-core
+  $(call AddDepends/sound)
+endef
+
+define KernelPackage/sound-soc-sun8i-codec/description
+  Kernel support for AllWinner built-in SoC audio sun8i-codec
+endef
+
+$(eval $(call KernelPackage,sound-soc-sun8i-codec))
+
+
+define KernelPackage/sun8i-adda-pr-regmap
+  TITLE:=AllWinner SoC sound sun4i-spdif
+  KCONFIG:=CONFIG_SND_SUN8I_ADDA_PR_REGMAP
+  FILES:=$(LINUX_DIR)/sound/soc/sunxi/sun8i-adda-pr-regmap.ko
+  AUTOLOAD:=$(call AutoLoad,67,sun8i-adda-pr-regmap)
+  DEPENDS:=@TARGET_sunxi +kmod-sound-soc-core
+  $(call AddDepends/sound)
+endef
+
+define KernelPackage/sun8i-adda-pr-regmap/description
+  Kernel support for AllWinner built-in SoC audio sun8i-adda-pr-regmap
+endef
+
+$(eval $(call KernelPackage,sun8i-adda-pr-regmap))
+
+
+define KernelPackage/sound-soc-sun8i-codec-analog
+  TITLE:=AllWinner SoC sound sun8i-codec-analog
+  KCONFIG:=CONFIG_SND_SUN8I_CODEC_ANALOG
+  FILES:=$(LINUX_DIR)/sound/soc/sunxi/sun8i-codec-analog.ko
+  AUTOLOAD:=$(call AutoLoad,67,sun8i-codec-analog)
+  DEPENDS:=@TARGET_sunxi +kmod-sound-soc-core +kmod-sun8i-adda-pr-regmap
+  $(call AddDepends/sound)
+endef
+
+define KernelPackage/sound-soc-sun8i-codec-analog/description
+  Kernel support for AllWinner built-in SoC audio sun8i-codec-analog
+endef
+
+$(eval $(call KernelPackage,sound-soc-sun8i-codec-analog))
+
+
+define KernelPackage/sound-soc-sun4i-i2s
+  TITLE:=AllWinner SoC sound sun4i-i2s
+  KCONFIG:=CONFIG_SND_SUN4I_I2S
+  FILES:=$(LINUX_DIR)/sound/soc/sunxi/sun4i-i2s.ko
+  AUTOLOAD:=$(call AutoLoad,67,sun4i-i2s)
+  DEPENDS:=@TARGET_sunxi +kmod-sound-soc-core
+  $(call AddDepends/sound)
+endef
+
+define KernelPackage/sound-soc-sun4i-i2s/description
+  Kernel support for AllWinner built-in SoC audio sun4i-i2s
+endef
+
+$(eval $(call KernelPackage,sound-soc-sun4i-i2s))
+
+
+define KernelPackage/sound-soc-sun4i-spdif
+  TITLE:=AllWinner SoC sound sun4i-spdif
+  KCONFIG:=CONFIG_SND_SUN4I_SPDIF
+  FILES:=$(LINUX_DIR)/sound/soc/sunxi/sun4i-spdif.ko
+  AUTOLOAD:=$(call AutoLoad,67,sun4i-spdif)
+  DEPENDS:=@TARGET_sunxi +kmod-sound-soc-core
+  $(call AddDepends/sound)
+endef
+
+define KernelPackage/sound-soc-sun4i-spdif/description
+  Kernel support for AllWinner built-in SoC audio sun4i-spdif
+endef
+
+$(eval $(call KernelPackage,sound-soc-sun4i-spdif))
+
+
+define KernelPackage/pwm-regulator
+  SUBMENU:=$(OTHER_MENU)
+  TITLE:=Generic pwm-regulator driver
+  DEPENDS:=@TARGET_sunxi
+  KCONFIG:= \
+	CONFIG_REGULATOR_PWM=m
+  FILES:=$(LINUX_DIR)/drivers/regulator/pwm-regulator.ko
+  AUTOLOAD:=$(call AutoProbe,pwm-regulator)
+endef
+
+$(eval $(call KernelPackage,pwm-regulator))
+
+
+define KernelPackage/clk-pwm
+  SUBMENU:=$(OTHER_MENU)
+  TITLE:=Generic clk-pwm driver
+  DEPENDS:=@TARGET_sunxi
+  KCONFIG:= \
+	CONFIG_COMMON_CLK_PWM=m
+  FILES:=$(LINUX_DIR)/drivers/clk/clk-pwm.ko
+  AUTOLOAD:=$(call AutoProbe,clk-pwm)
+endef
+
+$(eval $(call KernelPackage,clk-pwm))
+
+## thermal
+
+
+define KernelPackage/thermal-generic-adc
+  SUBMENU:=Sunxi Thermal
+  TITLE:=Generic GENERIC_ADC_THERMAL driver
+  DEPENDS:=@TARGET_sunxi
+  KCONFIG:=CONFIG_GENERIC_ADC_THERMAL=m
+  FILES:=$(LINUX_DIR)/drivers/thermal/thermal-generic-adc.ko
+  AUTOLOAD:=$(call AutoProbe,thermal-generic-adc)
+endef
+
+$(eval $(call KernelPackage,thermal-generic-adc))
--- a/target/linux/sunxi/image/cortexa7.mk	2021-04-19 22:10:14.000000000 +0300
+++ b/target/linux/sunxi/image/cortexa7.mk	2021-05-21 12:08:54.832003099 +0300
@@ -197,7 +197,8 @@
 define Device/xunlong_orangepi-r1
   DEVICE_VENDOR := Xunlong
   DEVICE_MODEL := Orange Pi R1
-  DEVICE_PACKAGES:=kmod-rtc-sunxi kmod-usb-net-rtl8152
+  DEVICE_PACKAGES:=kmod-rtc-sunxi kmod-usb-net-rtl8152 \
+	boot-config
   SOC := sun8i-h2-plus
 endef
 TARGET_DEVICES += xunlong_orangepi-r1
@@ -205,11 +206,21 @@
 define Device/xunlong_orangepi-zero
   DEVICE_VENDOR := Xunlong
   DEVICE_MODEL := Orange Pi Zero
-  DEVICE_PACKAGES:=kmod-rtc-sunxi
+  DEVICE_PACKAGES:=kmod-rtc-sunxi kmod-xradio \
+	boot-config
   SOC := sun8i-h2-plus
 endef
 TARGET_DEVICES += xunlong_orangepi-zero
 
+define Device/xunlong_orangepi-zero-lts
+  DEVICE_VENDOR := Xunlong
+  DEVICE_MODEL := Orange Pi Zero Lts
+  DEVICE_PACKAGES:=kmod-rtc-sunxi kmod-xradio \
+	boot-config
+  SOC := sun8i-h2-plus
+endef
+TARGET_DEVICES += xunlong_orangepi-zero-lts
+
 define Device/xunlong_orangepi-2
   DEVICE_VENDOR := Xunlong
   DEVICE_MODEL := Orange Pi 2
--- a/target/linux/sunxi/base-files/etc/rc.local	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/base-files/etc/rc.local	2021-05-08 21:04:39.775977117 +0300
@@ -0,0 +1,7 @@
+# Put your custom commands here that should be executed once
+# the system init finished. By default this file does nothing.
+
+amixer -c 0 -q set "Line Out" 80%+ unmute &
+amixer -c 0 -q set "DAC" 100%+ unmute &
+
+exit 0
--- a/target/linux/sunxi/patches-5.4/202-add0-pinctrl_wifi-xr819-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/202-add0-pinctrl_wifi-xr819-opi-zero.patch	2021-05-08 21:04:39.779977025 +0300
@@ -0,0 +1,31 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -49,6 +49,7 @@
+ 
+ #include <dt-bindings/gpio/gpio.h>
+ #include <dt-bindings/input/input.h>
++#include <dt-bindings/pinctrl/sun4i-a10.h>
+ 
+ / {
+ 	model = "Xunlong Orange Pi Zero";
+@@ -143,7 +166,8 @@
+ 	mmc-pwrseq = <&wifi_pwrseq>;
+ 	bus-width = <4>;
+ 	non-removable;
+-	status = "okay";
++	keep-power-in-suspend;
++	status = "disabled";
+ 
+ 	/*
+ 	 * Explicitly define the sdio device, so that we can add an ethernet
+@@ -151,6 +170,10 @@
+ 	 */
+ 	xr819: sdio_wifi@1 {
+ 		reg = <1>;
++		compatible = "xradio,xr819";
++		interrupt-parent = <&pio>;
++		interrupts = <6 10 IRQ_TYPE_EDGE_RISING>;
++		interrupt-names = "host-wake";
+ 	};
+ };
+ 
--- a/target/linux/sunxi/patches-5.4/203-add-enable-soc_audio-routing-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/203-add-enable-soc_audio-routing-opi-zero.patch	2021-05-08 21:04:39.779977025 +0300
@@ -0,0 +1,14 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -167,6 +190,11 @@
+ &ohci1 {
+ 	status = "okay";
+ };
++
++&codec { /* add audio-routing */
++	allwinner,audio-routing = "Line Out", "LINEOUT", 
++				"MIC1", "Mic", "Mic", "MBIAS";
++};
+ 
+ &spi0 {
+ 	/* Disable SPI NOR by default: it optional on Orange Pi Zero boards */
--- a/target/linux/sunxi/patches-5.4/204-add-IR-pinctrl-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/204-add-IR-pinctrl-opi-zero.patch	2021-05-08 21:04:39.779977025 +0300
@@ -0,0 +1,15 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -172,6 +200,12 @@
+ 	allwinner,audio-routing = "Line Out", "LINEOUT", 
+ 				"MIC1", "Mic", "Mic", "MBIAS";
+ };
++
++&ir {
++	pinctrl-names = "default";
++	pinctrl-0 = <&r_ir_rx_pin>;
++	status = "disabled";
++};
+ 
+ &spi0 {
+ 	/* Disable SPI NOR by default: it optional on Orange Pi Zero boards */
--- a/target/linux/sunxi/patches-5.4/205-add-w1-gpio_pinctrl-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/205-add-w1-gpio_pinctrl-opi-zero.patch	2021-05-08 21:04:39.779977025 +0300
@@ -0,0 +1,39 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -80,6 +90,18 @@
+ 			gpios = <&pio 0 17 GPIO_ACTIVE_HIGH>;
+ 		};
+ 	};
++
++	w1: w1 {
++		compatible = "w1-gpio";
++		/*
++		* PWM1/PA10 pin on Orange Pi Zero gpio-10
++		* (0 this is A port, 10 this is gpio-10. for PD14 use  <&pio 3 14 GPIO_ACTIVE_LOW>)
++		*/
++		gpios = <&pio 0 10 (GPIO_ACTIVE_LOW|GPIO_OPEN_DRAIN)>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&w1_pins>;
++		status = "disabled";
++	};
+ 
+ 	reg_vcc_wifi: reg_vcc_wifi {
+ 		compatible = "regulator-fixed";
+@@ -178,6 +200,17 @@
+ 	pinctrl-0 = <&r_ir_rx_pin>;
+ 	status = "disabled";
+ };
++
++&pio {
++	w1_pins: w1_pins {
++		/*
++		* PWM1/PA10 pin on Orange Pi Zero gpio-10
++		*/
++		pins = "PA10";
++		function = "gpio_in";	// in (initially)
++		pull = <0x00>;		// off
++	};
++};
+ 
+ &spi0 {
+ 	/* Disable SPI NOR by default: it optional on Orange Pi Zero boards */
--- a/target/linux/sunxi/patches-5.4/206-add-PA5-pwm_pin-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/206-add-PA5-pwm_pin-opi-zero.patch	2021-05-08 21:04:39.779977025 +0300
@@ -0,0 +1,22 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -200,7 +250,19 @@
+ 		function = "gpio_in";	// in (initially)
+ 		pull = <0x00>;		// off
+ 	};
++
++	pwm0_pin: pwm0 {
++		pins = "PA5";
++		function = "pwm0";
++		drive = <SUN4I_PINCTRL_10_MA>;
++		pull = <SUN4I_PINCTRL_NO_PULL>;
++	};
+ };
++
++&pwm {
++	pinctrl-names = "default";
++	pinctrl-0 = <&pwm0_pin>;
++};
+ 
+ &spi0 {
+ 	/* Disable SPI NOR by default: it optional on Orange Pi Zero boards */
--- a/target/linux/sunxi/patches-5.4/207-add1-ths-sun8i-h3_sunxi-h3-h5.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/207-add1-ths-sun8i-h3_sunxi-h3-h5.patch	2021-05-08 21:04:39.779977025 +0300
@@ -0,0 +1,85 @@
+--- a/arch/arm/boot/dts/sunxi-h3-h5.dtsi	2020-02-24 09:34:54.000000000 +0200
++++ b/arch/arm/boot/dts/sunxi-h3-h5.dtsi	2020-03-07 23:29:05.966849280 +0200
+@@ -47,6 +47,7 @@
+ #include <dt-bindings/reset/sun8i-de2.h>
+ #include <dt-bindings/reset/sun8i-h3-ccu.h>
+ #include <dt-bindings/reset/sun8i-r-ccu.h>
++#include <dt-bindings/thermal/thermal.h>
+ 
+ / {
+ 	interrupt-parent = <&gic>;
+@@ -146,6 +159,17 @@
+ 			};
+ 		};
+ 
++		ths: thermal-sensor@1c25000 {
++			compatible = "allwinner,sun8i-h3-ths";
++			reg = <0x01c25000 0x100>;
++			interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&ccu CLK_BUS_THS>, <&ccu CLK_THS>;
++			clock-names = "bus", "mod";
++			resets = <&ccu RST_BUS_THS>;
++			#io-channel-cells = <0>;
++			#thermal-sensor-cells = <0>;
++		};
++
+ 		dma: dma-controller@1c02000 {
+ 			compatible = "allwinner,sun8i-h3-dma";
+ 			reg = <0x01c02000 0x1000>;
+@@ -873,4 +900,32 @@
+ 			};
+ 		};
+ 	};
++
++	thermal-zones {
++		cpu_thermal: cpu_thermal {
++			polling-delay-passive = <330>;
++			polling-delay = <1000>;
++			thermal-sensors = <&ths 0>;
++
++			trips {
++				cpu_hot_trip: cpu-warm {
++					temperature = <65000>; /* ~65°C */
++					hysteresis = <2000>;
++					type = "passive";
++				};
++				cpu_very_hot_trip: cpu-very-hot {
++					temperature = <90000>; /* ~90°C */
++					hysteresis = <2000>;
++					type = "critical";
++				};
++			};
++
++			cooling-maps {
++				cpu-warm-limit {
++					trip = <&cpu_hot_trip>;
++					cooling-device = <&cpu0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
++				};
++			};
++		};
++	};
+ };
+--- a/arch/arm/boot/dts/sun8i-h3.dtsi	2020-02-24 09:34:54.000000000 +0200
++++ b/arch/arm/boot/dts/sun8i-h3.dtsi	2020-03-07 23:17:31.075403499 +0200
+@@ -47,6 +49,12 @@
+ 		compatible = "operating-points-v2";
+ 		opp-shared;
+ 
++		opp-480000000 {
++			opp-hz = /bits/ 64 <480000000>;
++			opp-microvolt = <1040000 1040000 1300000>;
++			clock-latency-ns = <244144>; /* 8 32k periods */
++		};
++
+ 		opp-648000000 {
+ 			opp-hz = /bits/ 64 <648000000>;
+ 			opp-microvolt = <1040000 1040000 1300000>;
+@@ -77,6 +83,8 @@
+ 			clocks = <&ccu CLK_CPUX>;
+ 			clock-names = "cpu";
+ 			operating-points-v2 = <&cpu0_opp_table>;
++			cooling-min-level = <0>;
++			cooling-max-level = <15>;
+ 			#cooling-cells = <2>;
+ 		};
+ 
--- a/target/linux/sunxi/patches-5.4/207-add3-sunxi-ths_linux.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/207-add3-sunxi-ths_linux.patch	2021-05-08 21:04:39.779977025 +0300
@@ -0,0 +1,822 @@
+--- a/drivers/thermal/Kconfig
++++ b/drivers/thermal/Kconfig
+@@ -348,6 +385,24 @@
+ 	  Enable this option if you want to have support for thermal management
+ 	  controller present in Mediatek SoCs
+ 
++config SUN50I_H6_THS
++	tristate "Thermal sensor driver for Allwinner H6"
++	depends on ARCH_SUNXI || COMPILE_TEST
++	depends on HAS_IOMEM
++	depends on NVMEM
++	depends on OF
++	depends on RESET_CONTROLLER
++	help
++	  Enable this option if you want to have support for thermal reporting
++	  on Allwinner H6.
++
++config SUN8I_THS
++	tristate "Thermal sensor driver for Allwinner H3"
++	depends on MACH_SUN8I || (ARM64 && ARCH_SUNXI)
++	depends on OF
++	help
++	  Enable this to support thermal reporting on some newer Allwinner SoCs.
++
+ menu "Intel thermal drivers"
+ depends on X86 || X86_INTEL_QUARK || COMPILE_TEST
+ source "drivers/thermal/intel/Kconfig"
+--- a/drivers/thermal/Makefile
++++ b/drivers/thermal/Makefile
+@@ -54,3 +58,5 @@
+ obj-$(CONFIG_GENERIC_ADC_THERMAL)	+= thermal-generic-adc.o
+ obj-$(CONFIG_ZX2967_THERMAL)	+= zx2967_thermal.o
+ obj-$(CONFIG_UNIPHIER_THERMAL)	+= uniphier_thermal.o
++obj-$(CONFIG_SUN50I_H6_THS)	+= sun50i_h6_ths.o
++obj-$(CONFIG_SUN8I_THS)		+= sun8i_ths.o
+--- a/drivers/thermal/sun50i_h6_ths.c	1970-01-01 03:00:00.000000000 +0300
++++ b/drivers/thermal/sun50i_h6_ths.c	2019-03-12 10:34:36.414619070 +0200
+@@ -0,0 +1,365 @@
++/*
++ * Thermal sensor driver for Allwinner H6
++ *
++ * Copyright (C) 2018 Icenowy Zheng
++ *
++ * Based on the work of Ondřej Jirman
++ * Based on the work of Josef Gajdusek <atx@atx.name>
++ *
++ * This software is licensed under the terms of the GNU General Public
++ * License version 2, as published by the Free Software Foundation, and
++ * may be copied, distributed, and modified under those terms.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ */
++
++#include <linux/clk.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/module.h>
++#include <linux/nvmem-consumer.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include <linux/reset.h>
++#include <linux/slab.h>
++#include <linux/thermal.h>
++#include <linux/printk.h>
++
++#define THS_H6_MAX_SENSOR_NUM	4
++
++#define THS_H6_CTRL0		0x00
++#define THS_H6_CTRL2		0x04
++#define THS_H6_PER		0x08
++#define THS_H6_DATA_INT_CTRL	0x10
++#define THS_H6_DATA_INT_STAT	0x20
++#define THS_H6_FILTER		0x30
++#define THS_H6_CDATA(n)		(0xa0 + 4 * (n))
++#define THS_H6_DATA(n)		(0xc0 + 4 * (n))
++
++#define THS_H6_CTRL0_SENSOR_ACQ0(x)	((x) << 16)
++#define THS_H6_CTRL2_SENSE_EN(n)	BIT(0 + (n))
++#define THS_H6_PER_THERMAL_PER(x)	((x) << 12)
++#define THS_H6_INT_CTRL_DATA_IRQ_EN(n)	BIT(0 + (n))
++#define THS_H6_STAT_DATA_IRQ_STS(n)	BIT(0 + (n))
++#define THS_H6_FILTER_TYPE(x)		((x) << 0)
++#define THS_H6_FILTER_EN		BIT(2)
++
++#define THS_H6_CLK_IN		240000000 /* Hz */
++#define THS_H6_DATA_PERIOD	10 /* ms */
++
++#define THS_H6_FILTER_TYPE_VALUE	2 /* average over 2^(n+1) samples */
++#define THS_H6_FILTER_DIV		(1 << (THS_H6_FILTER_TYPE_VALUE + 1))
++#define THS_H6_INT_CTRL_THERMAL_PER_VALUE \
++	(THS_H6_DATA_PERIOD * (THS_H6_CLK_IN / 1000) / THS_H6_FILTER_DIV / 4096 - 1)
++#define THS_H6_CTRL0_SENSOR_ACQ0_VALUE	0x1df /* 20us */
++#define THS_H6_CTRL0_UNK		0x0000002f
++
++#define THS_H6_CAL_FT_TEMP_MASK		0x0fff
++#define THS_H6_CAL_FT_TEMP_DEVIATION_EN	0x3000
++#define THS_H6_CAL_DEFAULT		0x800
++#define THS_H6_CAL_VAL_MASK		0xfff
++
++struct sun50i_h6_ths_data;
++
++struct sun50i_h6_ths_sensor {
++	struct sun50i_h6_ths_data *data;
++	int id;
++	struct thermal_zone_device *tzd;
++	u32 val;
++};
++
++struct sun50i_h6_ths_cfg {
++	int sensor_num;
++	int (*calc_temp)(u32 val);
++};
++
++struct sun50i_h6_ths_data {
++	struct reset_control *reset;
++	struct clk *busclk;
++	void __iomem *regs;
++	const struct sun50i_h6_ths_cfg *cfg;
++	struct nvmem_cell *calcell;
++	struct sun50i_h6_ths_sensor sensors[THS_H6_MAX_SENSOR_NUM];
++};
++
++static int sun50i_h6_ths_calc_temp(u32 val)
++{
++	return (187744 - (int)((val * 1000000) / 14882));
++}
++
++static u16 sun50i_h6_ths_recalc_reg(u32 temp)
++{
++	return (u16)(2794 - temp * 14882 / 1000000);
++}
++
++static int sun50i_h6_ths_get_temp(void *_data, int *out)
++{
++	struct sun50i_h6_ths_sensor *sensor = _data;
++
++	if (sensor->val == 0)
++		return -EBUSY;
++
++	/* Formula and parameters from the Allwinner 3.4 kernel */
++	*out = sensor->data->cfg->calc_temp(sensor->val);
++	return 0;
++}
++
++static irqreturn_t sun50i_h6_ths_irq_thread(int irq, void *_data)
++{
++	struct sun50i_h6_ths_data *data = _data;
++	int i;
++
++	for (i = 0; i < data->cfg->sensor_num; i++) {
++		if (!(readl(data->regs + THS_H6_DATA_INT_STAT) &
++		      THS_H6_STAT_DATA_IRQ_STS(i)))
++			continue;
++
++		writel(THS_H6_STAT_DATA_IRQ_STS(i),
++		       data->regs + THS_H6_DATA_INT_STAT);
++
++		data->sensors[i].val = readl(data->regs + THS_H6_DATA(i));
++		if (data->sensors[i].val)
++			thermal_zone_device_update(data->sensors[i].tzd,
++						   THERMAL_EVENT_TEMP_SAMPLE);
++	}
++
++	return IRQ_HANDLED;
++}
++
++static void sun50i_h6_ths_init(struct sun50i_h6_ths_data *data)
++{
++	u32 val;
++	int i;
++
++	writel(THS_H6_CTRL0_SENSOR_ACQ0(THS_H6_CTRL0_SENSOR_ACQ0_VALUE) |
++	       THS_H6_CTRL0_UNK, data->regs + THS_H6_CTRL0);
++	writel(THS_H6_FILTER_EN | THS_H6_FILTER_TYPE(THS_H6_FILTER_TYPE_VALUE),
++	       data->regs + THS_H6_FILTER);
++
++	val = 0;
++	for (i = 0; i < data->cfg->sensor_num; i++)
++		val |= THS_H6_CTRL2_SENSE_EN(i);
++	writel(val, data->regs + THS_H6_CTRL2);
++
++	val = THS_H6_PER_THERMAL_PER(THS_H6_INT_CTRL_THERMAL_PER_VALUE);
++	writel(val, data->regs + THS_H6_PER);
++
++	val = 0;
++	for (i = 0; i < data->cfg->sensor_num; i++)
++		val |= THS_H6_INT_CTRL_DATA_IRQ_EN(i);
++	writel(val, data->regs + THS_H6_DATA_INT_CTRL);
++}
++
++static const struct thermal_zone_of_device_ops sun50i_h6_ths_thermal_ops = {
++	.get_temp = sun50i_h6_ths_get_temp,
++};
++
++static int sun50i_h6_ths_calibrate(struct sun50i_h6_ths_data *data)
++{
++	u16 *caldata;
++	size_t callen;
++	int i;
++	int ft_temp;
++	s16 ft_temp_orig_reg, diff, cal_val;
++	u32 reg_val;
++
++	caldata = nvmem_cell_read(data->calcell, &callen);
++	if (IS_ERR(caldata))
++		return PTR_ERR(caldata);
++
++	if (callen < 2 + 2 * data->cfg->sensor_num)
++		return -EINVAL;
++
++	if (!caldata[0])
++		return -EINVAL;
++
++	/*
++	 * The calbration data on H6 is stored as temperature-value
++	 * pair when being filled at factory test stage.
++	 * The unit of stored FT temperature is 0.1 degreee celusis.
++	 */
++	ft_temp = (caldata[0] & THS_H6_CAL_FT_TEMP_MASK) * 100;
++	ft_temp_orig_reg = sun50i_h6_ths_recalc_reg(ft_temp);
++
++	for (i = 0; i < data->cfg->sensor_num; i++)
++	{
++		diff = (ft_temp_orig_reg - (s16)caldata[1 + i]);
++		cal_val = THS_H6_CAL_DEFAULT - diff;
++
++		if (cal_val & ~THS_H6_CAL_VAL_MASK) {
++			pr_warn("Faulty thermal sensor %d calibration value, beyond the valid range.\n", i);
++			continue;
++		}
++
++		if (i % 2) {
++			reg_val = readl(data->regs + THS_H6_CDATA(i / 2));
++			reg_val &= 0xffff;
++			reg_val |= cal_val << 16;
++			writel(reg_val, data->regs + THS_H6_CDATA(i / 2));
++		} else {
++			writel(cal_val, data->regs + THS_H6_CDATA(i / 2));
++		}
++	}
++
++	kfree(caldata);
++	return 0;
++}
++
++static int sun50i_h6_ths_probe(struct platform_device *pdev)
++{
++	struct sun50i_h6_ths_data *data;
++	struct resource *res;
++	int ret, irq, i;
++
++	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
++	if (!data)
++		return -ENOMEM;
++
++	data->cfg = of_device_get_match_data(&pdev->dev);
++	if (!data->cfg)
++		return -EINVAL;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!res) {
++		dev_err(&pdev->dev, "no memory resources defined\n");
++		return -EINVAL;
++	}
++
++	data->regs = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(data->regs)) {
++		ret = PTR_ERR(data->regs);
++		dev_err(&pdev->dev, "failed to ioremap THS registers: %d\n", ret);
++		return ret;
++	}
++
++	irq = platform_get_irq(pdev, 0);
++	if (irq < 0) {
++		dev_err(&pdev->dev, "failed to get IRQ: %d\n", irq);
++		return irq;
++	}
++
++	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
++					sun50i_h6_ths_irq_thread, IRQF_ONESHOT,
++					dev_name(&pdev->dev), data);
++	if (ret)
++		return ret;
++
++	data->busclk = devm_clk_get(&pdev->dev, "bus");
++	if (IS_ERR(data->busclk)) {
++		ret = PTR_ERR(data->busclk);
++		dev_err(&pdev->dev, "failed to get ahb clk: %d\n", ret);
++		return ret;
++	}
++
++	data->reset = devm_reset_control_get(&pdev->dev, NULL);
++	if (IS_ERR(data->reset)) {
++		ret = PTR_ERR(data->reset);
++		dev_err(&pdev->dev, "failed to get reset: %d\n", ret);
++		return ret;
++	}
++
++	ret = reset_control_deassert(data->reset);
++	if (ret) {
++		dev_err(&pdev->dev, "reset deassert failed: %d\n", ret);
++		return ret;
++	}
++
++	ret = clk_prepare_enable(data->busclk);
++	if (ret) {
++		dev_err(&pdev->dev, "failed to enable bus clk: %d\n", ret);
++		goto err_assert_reset;
++	}
++
++	data->calcell = devm_nvmem_cell_get(&pdev->dev, "calibration");
++	if (IS_ERR(data->calcell)) {
++		if (PTR_ERR(data->calcell) == -EPROBE_DEFER) {
++			ret = PTR_ERR(data->calcell);
++			goto err_disable_bus;
++		}
++		/*
++		* Even if the external calibration data stored in eFUSE is
++		* not accessible, the THS hardware can still work, although
++		* the data won't be so accurate.
++		* The default value of calibration register is 0x800 for
++		* every sensor, and the calibration value is usually 0x7xx
++		* or 0x8xx, so they won't be away from the default value
++		* for a lot.
++		* So here we do not return if the calibartion data is not
++		* available, except the probe needs deferring.
++		*/
++	} else {
++		ret = sun50i_h6_ths_calibrate(data);
++		if (ret) {
++			/* Revert calibrating */
++			for (i = 0; i < data->cfg->sensor_num; i += 2) {
++				writew(THS_H6_CAL_DEFAULT,
++				       data->regs + THS_H6_CDATA(i / 2));
++			}
++		}
++	}
++
++	for (i = 0; i < data->cfg->sensor_num; i++) {
++		data->sensors[i].data = data;
++		data->sensors[i].id = i;
++		data->sensors[i].tzd =
++			devm_thermal_zone_of_sensor_register(&pdev->dev,
++				i, &data->sensors[i], &sun50i_h6_ths_thermal_ops);
++		if (IS_ERR(data->sensors[i].tzd)) {
++			ret = PTR_ERR(data->sensors[i].tzd);
++			dev_err(&pdev->dev,
++				"failed to register thermal zone %d: %d\n",
++				i, ret);
++			goto err_disable_bus;
++		}
++	}
++
++	sun50i_h6_ths_init(data);
++
++	platform_set_drvdata(pdev, data);
++	return 0;
++
++err_disable_bus:
++	clk_disable_unprepare(data->busclk);
++err_assert_reset:
++	reset_control_assert(data->reset);
++	return ret;
++}
++
++static int sun50i_h6_ths_remove(struct platform_device *pdev)
++{
++	struct sun50i_h6_ths_data *data = platform_get_drvdata(pdev);
++
++	reset_control_assert(data->reset);
++	clk_disable_unprepare(data->busclk);
++	return 0;
++}
++
++static const struct sun50i_h6_ths_cfg sun50i_h6_ths_cfg = {
++	.sensor_num = 2,
++	.calc_temp = sun50i_h6_ths_calc_temp,
++};
++
++static const struct of_device_id sun50i_h6_ths_id_table[] = {
++	{ .compatible = "allwinner,sun50i-h6-ths", .data = &sun50i_h6_ths_cfg },
++	{ /* sentinel */ },
++};
++MODULE_DEVICE_TABLE(of, sun50i_h6_ths_id_table);
++
++static struct platform_driver sun50i_h6_ths_driver = {
++	.probe = sun50i_h6_ths_probe,
++	.remove = sun50i_h6_ths_remove,
++	.driver = {
++		.name = "sun50i_h6_ths",
++		.of_match_table = sun50i_h6_ths_id_table,
++	},
++};
++
++module_platform_driver(sun50i_h6_ths_driver);
++
++MODULE_AUTHOR("Icenowy Zheng <icenowy@aosc.io>");
++MODULE_DESCRIPTION("Thermal sensor driver for Allwinner H6");
++MODULE_LICENSE("GPL v2");
+--- a/drivers/thermal/sun8i_ths.c	1970-01-01 03:00:00.000000000 +0300
++++ b/drivers/thermal/sun8i_ths.c	2019-03-12 00:33:20.246514437 +0200
+@@ -0,0 +1,416 @@
++/*
++ * Thermal sensor driver for Allwinner SUN8I SoC
++ *
++ * Copyright (C) 2016 Ondřej Jirman
++ * Based on the work of Josef Gajdusek <atx@atx.name>
++ *
++ * This software is licensed under the terms of the GNU General Public
++ * License version 2, as published by the Free Software Foundation, and
++ * may be copied, distributed, and modified under those terms.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ */
++
++#include <linux/clk.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/module.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include <linux/reset.h>
++#include <linux/slab.h>
++#include <linux/thermal.h>
++#include <linux/printk.h>
++
++#define THS_SUN8I_CTRL0		0x00
++#define THS_SUN8I_CTRL2		0x40
++#define THS_SUN8I_INT_CTRL	0x44
++#define THS_SUN8I_STAT		0x48
++#define THS_SUN8I_FILTER	0x70
++#define THS_SUN8I_CDATA01	0x74
++#define THS_SUN8I_CDATA2	0x78
++#define THS_SUN8I_DATA0		0x80
++#define THS_SUN8I_DATA1		0x84
++#define THS_SUN8I_DATA2		0x88
++
++#define THS_SUN8I_CTRL0_SENSOR_ACQ0(x)		(x)
++#define THS_SUN8I_CTRL2_SENSE_EN0		BIT(0)
++#define THS_SUN8I_CTRL2_SENSE_EN1		BIT(1)
++#define THS_SUN8I_CTRL2_SENSE_EN2		BIT(2)
++#define THS_SUN8I_CTRL2_SENSOR_ACQ1(x)		((x) << 16)
++#define THS_SUN8I_INT_CTRL_DATA0_IRQ_EN		BIT(8)
++#define THS_SUN8I_INT_CTRL_DATA1_IRQ_EN		BIT(9)
++#define THS_SUN8I_INT_CTRL_DATA2_IRQ_EN		BIT(10)
++#define THS_SUN8I_INT_CTRL_THERMAL_PER(x)	((x) << 12)
++#define THS_SUN8I_STAT_DATA0_IRQ_STS		BIT(8)
++#define THS_SUN8I_STAT_DATA1_IRQ_STS		BIT(9)
++#define THS_SUN8I_STAT_DATA2_IRQ_STS		BIT(10)
++#define THS_SUN8I_STAT_CLEAR			0x777
++#define THS_SUN8I_FILTER_TYPE(x)		((x) << 0)
++#define THS_SUN8I_FILTER_EN			BIT(2)
++
++#define THS_SUN8I_CLK_IN		40000000 /* Hz */
++#define THS_SUN8I_DATA_PERIOD		330 /* ms */
++#define THS_SUN8I_FILTER_TYPE_VALUE	2 /* average over 2^(n+1) samples */
++
++//XXX: this formula doesn't work for A83T very well
++//XXX: A83T is getting slower readings out of this (1s interval?)
++//perhaps configure this in sun8i_ths_desc
++#define THS_SUN8I_FILTER_DIV		(1 << (THS_SUN8I_FILTER_TYPE_VALUE + 1))
++#define THS_SUN8I_INT_CTRL_THERMAL_PER_VALUE \
++	(THS_SUN8I_DATA_PERIOD * (THS_SUN8I_CLK_IN / 1000) / \
++	 THS_SUN8I_FILTER_DIV / 4096 - 1)
++
++#define THS_SUN8I_CTRL0_SENSOR_ACQ0_VALUE	0x3f /* 16us */
++#define THS_SUN8I_CTRL2_SENSOR_ACQ1_VALUE	0x3f
++
++#define SUN8I_THS_MAX_TZDS 3
++
++struct sun8i_ths_sensor_desc {
++	u32 data_int_en;
++	u32 data_int_flag;
++	u32 data_offset;
++	u32 sense_en;
++};
++
++struct sun8i_ths_desc {
++	int num_sensors;
++	struct sun8i_ths_sensor_desc *sensors;
++	int (*calc_temp)(u32 reg_val);
++	bool has_cal1;
++};
++
++struct sun8i_ths_tzd {
++	struct sun8i_ths_data *data;
++	struct thermal_zone_device *tzd;
++	u32 temp;
++};
++
++struct sun8i_ths_data {
++	struct device *dev;
++	struct reset_control *reset;
++	struct clk *clk;
++	struct clk *busclk;
++	void __iomem *regs;
++	void __iomem *cal_regs;
++	struct sun8i_ths_desc *desc;
++	struct sun8i_ths_tzd tzds[SUN8I_THS_MAX_TZDS];
++};
++
++static int sun8i_ths_calc_temp_h3(u32 reg_val)
++{
++	uint64_t temp = (uint64_t)reg_val * 1000000ll;
++
++        do_div(temp, 8253);
++
++	return 217000 - (int)temp;
++}
++
++static int sun8i_ths_calc_temp_a83t(u32 reg_val)
++{
++	uint64_t temp = (uint64_t)reg_val * 1000000ll;
++
++        do_div(temp, 14186);
++
++	return 192000 - (int)temp;
++}
++
++static int sun8i_ths_get_temp(void *_data, int *out)
++{
++	struct sun8i_ths_tzd *tzd = _data;
++	struct sun8i_ths_data *data = tzd->data;
++
++	if (tzd->temp == 0)
++		return -EBUSY;
++
++	*out = data->desc->calc_temp(tzd->temp);
++	return 0;
++}
++
++static irqreturn_t sun8i_ths_irq_thread(int irq, void *_data)
++{
++	struct sun8i_ths_data *data = _data;
++	struct sun8i_ths_tzd *tzd;
++	struct sun8i_ths_sensor_desc *zdesc;
++	int i;
++	u32 status;
++
++	status = readl(data->regs + THS_SUN8I_STAT);
++	writel(THS_SUN8I_STAT_CLEAR, data->regs + THS_SUN8I_STAT);
++
++	for (i = 0; i < data->desc->num_sensors; i++) {
++		tzd = &data->tzds[i];
++		zdesc = &data->desc->sensors[i];
++
++		if (status & zdesc->data_int_flag) {
++			tzd->temp = readl(data->regs + zdesc->data_offset);
++			if (tzd->temp)
++				thermal_zone_device_update(tzd->tzd,
++							   THERMAL_EVENT_TEMP_SAMPLE);
++		}
++	}
++
++	return IRQ_HANDLED;
++}
++
++static void sun8i_ths_init(struct sun8i_ths_data *data)
++{
++	int i;
++	u32 int_ctrl = 0;
++	u32 ctrl2 = 0;
++
++	writel(THS_SUN8I_CTRL0_SENSOR_ACQ0(THS_SUN8I_CTRL0_SENSOR_ACQ0_VALUE),
++		data->regs + THS_SUN8I_CTRL0);
++	writel(THS_SUN8I_FILTER_EN | THS_SUN8I_FILTER_TYPE(THS_SUN8I_FILTER_TYPE_VALUE),
++		data->regs + THS_SUN8I_FILTER);
++
++	ctrl2 |= THS_SUN8I_CTRL2_SENSOR_ACQ1(THS_SUN8I_CTRL2_SENSOR_ACQ1_VALUE);
++	int_ctrl |= THS_SUN8I_INT_CTRL_THERMAL_PER(THS_SUN8I_INT_CTRL_THERMAL_PER_VALUE);
++
++	for (i = 0; i < data->desc->num_sensors; i++) {
++		ctrl2 |= data->desc->sensors[i].sense_en;
++		int_ctrl |= data->desc->sensors[i].data_int_en;
++	}
++
++	if (data->cal_regs) {
++		u32 cal0, cal1;
++
++		cal0 = readl(data->cal_regs);
++		if (cal0)
++			writel(cal0, data->regs + THS_SUN8I_CDATA01);
++
++		if (data->desc->has_cal1) {
++			cal1 = readl(data->cal_regs + 4);
++			if (cal1)
++				writel(cal1, data->regs + THS_SUN8I_CDATA2);
++		}
++	}
++
++	writel(ctrl2, data->regs + THS_SUN8I_CTRL2);
++
++	/* enable interrupts */
++	writel(int_ctrl, data->regs + THS_SUN8I_INT_CTRL);
++}
++
++static const struct thermal_zone_of_device_ops sun8i_ths_thermal_ops = {
++	.get_temp = sun8i_ths_get_temp,
++};
++
++static int sun8i_ths_probe(struct platform_device *pdev)
++{
++	struct sun8i_ths_data *data;
++	struct device *dev = &pdev->dev;
++	struct resource *res;
++	int ret, irq, i;
++
++	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
++	if (!data)
++		return -ENOMEM;
++
++	data->desc = (struct sun8i_ths_desc *)of_device_get_match_data(dev);
++	if (data->desc == NULL)
++		return -EINVAL;
++
++	data->dev = dev;
++	platform_set_drvdata(pdev, data);
++
++	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ths");
++        if (!res) {
++                dev_err(dev, "no memory resources defined\n");
++                return -EINVAL;
++        }
++
++	data->regs = devm_ioremap_resource(dev, res);
++	if (IS_ERR(data->regs)) {
++		ret = PTR_ERR(data->regs);
++		dev_err(dev, "failed to ioremap THS registers: %d\n", ret);
++		return ret;
++	}
++
++	/*XXX: use SRAM device in the future, instead of direct access to regs */
++	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "calibration");
++        if (res) {
++		data->cal_regs = devm_ioremap_resource(dev, res);
++		if (IS_ERR(data->cal_regs)) {
++			ret = PTR_ERR(data->cal_regs);
++			dev_err(dev, "failed to ioremap calibration SRAM: %d\n", ret);
++			return ret;
++		}
++        }
++
++	irq = platform_get_irq(pdev, 0);
++	if (irq < 0) {
++		dev_err(dev, "failed to get IRQ: %d\n", irq);
++		return irq;
++	}
++
++	ret = devm_request_threaded_irq(dev, irq, NULL,
++					sun8i_ths_irq_thread, IRQF_ONESHOT,
++					dev_name(dev), data);
++	if (ret)
++		return ret;
++
++	data->busclk = devm_clk_get(dev, "ahb");
++	if (IS_ERR(data->busclk)) {
++		ret = PTR_ERR(data->busclk);
++		if (ret != -ENOENT) {
++			dev_err(dev, "failed to get ahb clk: %d\n", ret);
++			return ret;
++		}
++
++		data->busclk = NULL;
++	}
++
++	data->clk = devm_clk_get(dev, "ths");
++	if (IS_ERR(data->clk)) {
++		ret = PTR_ERR(data->clk);
++		if (ret != -ENOENT) {
++			dev_err(dev, "failed to get ths clk: %d\n", ret);
++			return ret;
++		}
++
++		data->clk = NULL;
++	}
++
++	data->reset = devm_reset_control_get_optional(dev, "ahb");
++	if (IS_ERR(data->reset)) {
++		ret = PTR_ERR(data->reset);
++		dev_err(dev, "failed to get reset: %d\n", ret);
++		return ret;
++	}
++
++	ret = reset_control_deassert(data->reset);
++	if (ret) {
++		dev_err(dev, "reset deassert failed: %d\n", ret);
++		return ret;
++	}
++
++	if (data->busclk) {
++		ret = clk_prepare_enable(data->busclk);
++		if (ret) {
++			dev_err(dev, "failed to enable bus clk: %d\n", ret);
++			goto err_assert_reset;
++		}
++	}
++
++	if (data->clk) {
++		ret = clk_prepare_enable(data->clk);
++		if (ret) {
++			dev_err(dev, "failed to enable ths clk: %d\n", ret);
++			goto err_disable_bus;
++		}
++
++		ret = clk_set_rate(data->clk, THS_SUN8I_CLK_IN);
++		if (ret)
++			goto err_disable_ths;
++	}
++
++	for (i = 0; i < data->desc->num_sensors; i++) {
++		data->tzds[i].data = data;
++		data->tzds[i].tzd =
++			devm_thermal_zone_of_sensor_register(dev, i,
++							     &data->tzds[i],
++							     &sun8i_ths_thermal_ops);
++		if (IS_ERR(data->tzds[i].tzd)) {
++			ret = PTR_ERR(data->tzds[i].tzd);
++			dev_err(dev,
++				"failed to register thermal zone: %d\n", ret);
++			goto err_disable_ths;
++		}
++	}
++
++	sun8i_ths_init(data);
++	return 0;
++
++err_disable_ths:
++	if (data->clk)
++		clk_disable_unprepare(data->clk);
++err_disable_bus:
++	if (data->busclk)
++		clk_disable_unprepare(data->busclk);
++err_assert_reset:
++	reset_control_assert(data->reset);
++	return ret;
++}
++
++static int sun8i_ths_remove(struct platform_device *pdev)
++{
++	struct sun8i_ths_data *data = platform_get_drvdata(pdev);
++
++	reset_control_assert(data->reset);
++	if (data->clk)
++		clk_disable_unprepare(data->clk);
++	if (data->busclk)
++		clk_disable_unprepare(data->busclk);
++	return 0;
++}
++
++struct sun8i_ths_sensor_desc sun8i_ths_h3_sensors[] = {
++	{
++		.data_int_en = THS_SUN8I_INT_CTRL_DATA0_IRQ_EN,
++		.data_int_flag = THS_SUN8I_STAT_DATA0_IRQ_STS,
++		.data_offset = THS_SUN8I_DATA0,
++		.sense_en = THS_SUN8I_CTRL2_SENSE_EN0,
++	},
++};
++
++struct sun8i_ths_sensor_desc sun8i_ths_a83t_sensors[] = {
++	{
++		.data_int_en = THS_SUN8I_INT_CTRL_DATA0_IRQ_EN,
++		.data_int_flag = THS_SUN8I_STAT_DATA0_IRQ_STS,
++		.data_offset = THS_SUN8I_DATA0,
++		.sense_en = THS_SUN8I_CTRL2_SENSE_EN0,
++	},
++	{
++		.data_int_en = THS_SUN8I_INT_CTRL_DATA1_IRQ_EN,
++		.data_int_flag = THS_SUN8I_STAT_DATA1_IRQ_STS,
++		.data_offset = THS_SUN8I_DATA1,
++		.sense_en = THS_SUN8I_CTRL2_SENSE_EN1,
++	},
++	{
++		.data_int_en = THS_SUN8I_INT_CTRL_DATA2_IRQ_EN,
++		.data_int_flag = THS_SUN8I_STAT_DATA2_IRQ_STS,
++		.data_offset = THS_SUN8I_DATA2,
++		.sense_en = THS_SUN8I_CTRL2_SENSE_EN2,
++	},
++};
++
++static const struct sun8i_ths_desc sun8i_ths_h3_desc = {
++	.num_sensors = ARRAY_SIZE(sun8i_ths_h3_sensors),
++	.sensors = sun8i_ths_h3_sensors,
++	.calc_temp = sun8i_ths_calc_temp_h3,
++	.has_cal1 = false,
++};
++
++static const struct sun8i_ths_desc sun8i_ths_a83t_desc = {
++	.num_sensors = ARRAY_SIZE(sun8i_ths_a83t_sensors),
++	.sensors = sun8i_ths_a83t_sensors,
++	.calc_temp = sun8i_ths_calc_temp_a83t,
++	.has_cal1 = true,
++};
++
++static const struct of_device_id sun8i_ths_id_table[] = {
++	{ .compatible = "allwinner,sun8i-h3-ths", .data = &sun8i_ths_h3_desc },
++	{ .compatible = "allwinner,sun8i-a83t-ths", .data = &sun8i_ths_a83t_desc },
++	{ /* sentinel */ },
++};
++MODULE_DEVICE_TABLE(of, sun8i_ths_id_table);
++
++static struct platform_driver sun8i_ths_driver = {
++	.probe = sun8i_ths_probe,
++	.remove = sun8i_ths_remove,
++	.driver = {
++		.name = "sun8i_ths",
++		.of_match_table = sun8i_ths_id_table,
++	},
++};
++
++module_platform_driver(sun8i_ths_driver);
++
++MODULE_AUTHOR("Ondřej Jirman <megous@megous.com>");
++MODULE_DESCRIPTION("Thermal sensor driver for Allwinner SUN8I SoCs");
++MODULE_LICENSE("GPL v2");
--- a/target/linux/sunxi/patches-5.4/207-add4-sunxi-ths_gpadc_linux.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/207-add4-sunxi-ths_gpadc_linux.patch	2021-05-08 21:04:39.779977025 +0300
@@ -0,0 +1,717 @@
+--- a/drivers/iio/adc/sun4i-gpadc-iio.c
++++ b/drivers/iio/adc/sun4i-gpadc-iio.c
+@@ -19,15 +22,18 @@
+  * shutdown for not being used.
+  */
+ 
++#include <linux/clk.h>
+ #include <linux/completion.h>
+ #include <linux/interrupt.h>
+ #include <linux/io.h>
+ #include <linux/module.h>
++#include <linux/nvmem-consumer.h>
+ #include <linux/of.h>
+ #include <linux/of_device.h>
+ #include <linux/platform_device.h>
+ #include <linux/pm_runtime.h>
+ #include <linux/regmap.h>
++#include <linux/reset.h>
+ #include <linux/thermal.h>
+ #include <linux/delay.h>
+ 
+@@ -46,6 +52,18 @@
+ 	return SUN6I_GPADC_CTRL1_ADC_CHAN_SELECT(chan);
+ }
+ 
++struct sun4i_gpadc_iio;
++
++/*
++ * Prototypes for these functions, which enable these functions to be
++ * referenced in gpadc_data structures.
++ */
++static int sun4i_gpadc_sample_start(struct sun4i_gpadc_iio *info);
++static int sun4i_gpadc_sample_end(struct sun4i_gpadc_iio *info);
++
++static int sunxi_ths_sample_start(struct sun4i_gpadc_iio *info);
++static int sunxi_ths_sample_end(struct sun4i_gpadc_iio *info);
++
+ struct gpadc_data {
+ 	int		temp_offset;
+ 	int		temp_scale;
+@@ -53,6 +71,21 @@
+ 	unsigned int	tp_adc_select;
+ 	unsigned int	(*adc_chan_select)(unsigned int chan);
+ 	unsigned int	adc_chan_mask;
++	unsigned int	temp_data[MAX_SENSOR_COUNT];
++	int		(*sample_start)(struct sun4i_gpadc_iio *info);
++	int		(*sample_end)(struct sun4i_gpadc_iio *info);
++	u32		ctrl0_map;
++	u32		ctrl2_map;
++	u32		sensor_en_map;
++	u32		filter_map;
++	u32		irq_clear_map;
++	u32		irq_control_map;
++	bool		has_bus_clk;
++	bool		has_bus_rst;
++	bool		has_mod_clk;
++	int		sensor_count;
++	bool		supports_nvmem;
++	bool		support_irq;
+ };
+ 
+ static const struct gpadc_data sun4i_gpadc_data = {
+@@ -62,6 +95,12 @@
+ 	.tp_adc_select = SUN4I_GPADC_CTRL1_TP_ADC_SELECT,
+ 	.adc_chan_select = &sun4i_gpadc_chan_select,
+ 	.adc_chan_mask = SUN4I_GPADC_CTRL1_ADC_CHAN_MASK,
++	.temp_data = {SUN4I_GPADC_TEMP_DATA, 0, 0, 0},
++	.sample_start = sun4i_gpadc_sample_start,
++	.sample_end = sun4i_gpadc_sample_end,
++	.sensor_count = 1,
++	.supports_nvmem = false,
++	.support_irq = false,
+ };
+ 
+ static const struct gpadc_data sun5i_gpadc_data = {
+@@ -71,6 +110,12 @@
+ 	.tp_adc_select = SUN4I_GPADC_CTRL1_TP_ADC_SELECT,
+ 	.adc_chan_select = &sun4i_gpadc_chan_select,
+ 	.adc_chan_mask = SUN4I_GPADC_CTRL1_ADC_CHAN_MASK,
++	.temp_data = {SUN4I_GPADC_TEMP_DATA, 0, 0, 0},
++	.sample_start = sun4i_gpadc_sample_start,
++	.sample_end = sun4i_gpadc_sample_end,
++	.sensor_count = 1,
++	.supports_nvmem = false,
++	.support_irq = false,
+ };
+ 
+ static const struct gpadc_data sun6i_gpadc_data = {
+@@ -80,12 +125,203 @@
+ 	.tp_adc_select = SUN6I_GPADC_CTRL1_TP_ADC_SELECT,
+ 	.adc_chan_select = &sun6i_gpadc_chan_select,
+ 	.adc_chan_mask = SUN6I_GPADC_CTRL1_ADC_CHAN_MASK,
++	.temp_data = {SUN4I_GPADC_TEMP_DATA, 0, 0, 0},
++	.sample_start = sun4i_gpadc_sample_start,
++	.sample_end = sun4i_gpadc_sample_end,
++	.sensor_count = 1,
++	.supports_nvmem = false,
++	.support_irq = false,
+ };
+ 
+ static const struct gpadc_data sun8i_a33_gpadc_data = {
+ 	.temp_offset = -1662,
+ 	.temp_scale = 162,
+-	.tp_mode_en = SUN8I_GPADC_CTRL1_CHOP_TEMP_EN,
++	.tp_mode_en = SUN8I_A33_GPADC_CTRL1_CHOP_TEMP_EN,
++	.temp_data = {SUN4I_GPADC_TEMP_DATA, 0, 0, 0},
++	.sample_start = sun4i_gpadc_sample_start,
++	.sample_end = sun4i_gpadc_sample_end,
++	.sensor_count = 1,
++	.supports_nvmem = false,
++	.support_irq = false,
++};
++
++static const struct gpadc_data sun8i_h3_ths_data = {
++	.temp_offset = -1791,
++	.temp_scale = -121,
++	.temp_data = {SUNXI_THS_TDATA0, 0, 0, 0},
++	.sample_start = sunxi_ths_sample_start,
++	.sample_end = sunxi_ths_sample_end,
++	.has_bus_clk = true,
++	.has_bus_rst = true,
++	.has_mod_clk = true,
++	.sensor_count = 1,
++	.supports_nvmem = true,
++	.support_irq = true,
++	.ctrl0_map = SUNXI_THS_ACQ0(0xff),
++	.ctrl2_map = SUNXI_THS_ACQ1(0x3f),
++	.sensor_en_map = SUNXI_THS_TEMP_SENSE_EN0,
++	.filter_map = SUNXI_THS_FILTER_EN |
++		SUNXI_THS_FILTER_TYPE(0x2),
++	.irq_clear_map = SUNXI_THS_INTS_ALARM_INT_0 |
++			SUNXI_THS_INTS_SHUT_INT_0   |
++			SUNXI_THS_INTS_TDATA_IRQ_0  |
++			SUNXI_THS_INTS_ALARM_OFF_0,
++	.irq_control_map = SUNXI_THS_INTC_TDATA_IRQ_EN0 |
++		SUNXI_THS_TEMP_PERIOD(0x7),
++};
++
++static const struct gpadc_data sun8i_a83t_ths_data = {
++	.temp_offset = -2724,
++	.temp_scale = -70,
++	.temp_data = {SUNXI_THS_TDATA0,
++		SUNXI_THS_TDATA1,
++		SUNXI_THS_TDATA2,
++		0},
++	.sample_start = sunxi_ths_sample_start,
++	.sample_end = sunxi_ths_sample_end,
++	.sensor_count = 3,
++	.supports_nvmem = false,
++	.support_irq = true,
++	.ctrl0_map = SUNXI_THS_ACQ0(0x1f3),
++	.ctrl2_map = SUNXI_THS_ACQ1(0x1f3),
++	.sensor_en_map = SUNXI_THS_TEMP_SENSE_EN0 |
++		SUNXI_THS_TEMP_SENSE_EN1 |
++		SUNXI_THS_TEMP_SENSE_EN2,
++	.filter_map = SUNXI_THS_FILTER_EN |
++		SUNXI_THS_FILTER_TYPE(0x2),
++	.irq_clear_map = SUNXI_THS_INTS_ALARM_INT_0 |
++		SUNXI_THS_INTS_ALARM_INT_1 |
++		SUNXI_THS_INTS_ALARM_INT_2 |
++		SUNXI_THS_INTS_SHUT_INT_0  |
++		SUNXI_THS_INTS_SHUT_INT_1  |
++		SUNXI_THS_INTS_SHUT_INT_2  |
++		SUNXI_THS_INTS_TDATA_IRQ_0 |
++		SUNXI_THS_INTS_TDATA_IRQ_1 |
++		SUNXI_THS_INTS_TDATA_IRQ_2,
++	.irq_control_map = SUNXI_THS_INTC_TDATA_IRQ_EN0 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN1 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN2 |
++		SUNXI_THS_TEMP_PERIOD(0x257),
++};
++
++static const struct gpadc_data sun50i_h5_ths_data = {
++	.temp_offset = -1872,
++	.temp_scale = -119,
++	.temp_data = {SUNXI_THS_TDATA0,
++		SUNXI_THS_TDATA1, 0, 0},
++	.sample_start = sunxi_ths_sample_start,
++	.sample_end = sunxi_ths_sample_end,
++	.has_bus_clk = true,
++	.has_bus_rst = true,
++	.has_mod_clk = true,
++	.sensor_count = 2,
++	.supports_nvmem = false,
++	.support_irq = true,
++	.ctrl0_map = SUNXI_THS_ACQ0(0x1f3),
++	.ctrl2_map = SUNXI_THS_ACQ1(0x1f3),
++	.sensor_en_map = SUNXI_THS_TEMP_SENSE_EN0 |
++		SUNXI_THS_TEMP_SENSE_EN1,
++	.filter_map = SUNXI_THS_FILTER_EN |
++		SUNXI_THS_FILTER_TYPE(0x2),
++	.irq_clear_map = SUNXI_THS_INTS_ALARM_INT_0 |
++		SUNXI_THS_INTS_ALARM_INT_1 |
++		SUNXI_THS_INTS_SHUT_INT_0   |
++		SUNXI_THS_INTS_SHUT_INT_1   |
++		SUNXI_THS_INTS_TDATA_IRQ_0  |
++		SUNXI_THS_INTS_TDATA_IRQ_1  |
++		SUNXI_THS_INTS_ALARM_OFF_0  |
++		SUNXI_THS_INTS_ALARM_OFF_1,
++	.irq_control_map = SUNXI_THS_INTC_TDATA_IRQ_EN0 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN1 |
++		SUNXI_THS_TEMP_PERIOD(0x3a),
++};
++
++static const struct gpadc_data sun9i_a80_ths_data = {
++	.temp_offset = -2794,
++	.temp_scale = -67,
++	.temp_data = {SUNXI_THS_TDATA0,
++		SUNXI_THS_TDATA1,
++		SUNXI_THS_TDATA2,
++		SUNXI_THS_TDATA3},
++	.sample_start = sunxi_ths_sample_start,
++	.sample_end = sunxi_ths_sample_end,
++	.has_bus_clk = true,
++	.has_bus_rst = true,
++	.has_mod_clk = true,
++	.sensor_count = 4,
++	.supports_nvmem = false,
++	.support_irq = true,
++	.ctrl0_map = SUNXI_THS_ACQ0(0x1f3),
++	.ctrl2_map = SUNXI_THS_TEMP_SENSE_EN0 |
++		SUNXI_THS_TEMP_SENSE_EN1 |
++		SUNXI_THS_TEMP_SENSE_EN2 |
++		SUNXI_THS_TEMP_SENSE_EN3 |
++		SUNXI_THS_ACQ1(0x1f3),
++	.filter_map = SUNXI_THS_FILTER_EN |
++		SUNXI_THS_FILTER_TYPE(0x2),
++	.irq_clear_map = SUNXI_THS_INTS_ALARM_INT_0 |
++		SUNXI_THS_INTS_ALARM_INT_1 |
++		SUNXI_THS_INTS_ALARM_INT_2 |
++		SUNXI_THS_INTS_ALARM_INT_3 |
++		SUNXI_THS_INTS_SHUT_INT_0  |
++		SUNXI_THS_INTS_SHUT_INT_1  |
++		SUNXI_THS_INTS_SHUT_INT_2  |
++		SUNXI_THS_INTS_SHUT_INT_3  |
++		SUNXI_THS_INTS_TDATA_IRQ_0 |
++		SUNXI_THS_INTS_TDATA_IRQ_1 |
++		SUNXI_THS_INTS_TDATA_IRQ_2 |
++		SUNXI_THS_INTS_TDATA_IRQ_3,
++	.irq_control_map = SUNXI_THS_INTC_TDATA_IRQ_EN0 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN1 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN2 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN3 |
++		SUNXI_THS_TEMP_PERIOD(0x3a),
++};
++
++static const struct gpadc_data sun50i_a64_ths_data = {
++	.temp_offset = -2170,
++	.temp_scale = -117,
++	.temp_data = {SUNXI_THS_TDATA0,
++		SUNXI_THS_TDATA1,
++		SUNXI_THS_TDATA2,
++		0},
++	.sample_start = sunxi_ths_sample_start,
++	.sample_end = sunxi_ths_sample_end,
++	.has_bus_clk = true,
++	.has_bus_rst = true,
++	.has_mod_clk = true,
++	.sensor_count = 3,
++	.supports_nvmem = false,
++	.support_irq = true,
++
++	/* The final sample period is calculated as follows:
++	 * (THERMAL_PER + 1) * 4096 / 24MHz * 2^(FILTER_TYPE + 1)
++	 *
++	 * This results to about 1Hz with these settings.
++	 */
++	.ctrl0_map = SUNXI_THS_ACQ0(0xff),
++	.ctrl2_map = SUNXI_THS_TEMP_SENSE_EN0 |
++		SUNXI_THS_TEMP_SENSE_EN1 |
++		SUNXI_THS_TEMP_SENSE_EN2 |
++		SUNXI_THS_ACQ1(0x3f),
++	.filter_map = SUNXI_THS_FILTER_EN |
++		SUNXI_THS_FILTER_TYPE(0x1),
++	.irq_clear_map = SUNXI_THS_INTS_ALARM_INT_0 |
++		SUNXI_THS_INTS_ALARM_INT_1 |
++		SUNXI_THS_INTS_ALARM_INT_2 |
++		SUNXI_THS_INTS_SHUT_INT_0  |
++		SUNXI_THS_INTS_SHUT_INT_1  |
++		SUNXI_THS_INTS_SHUT_INT_2  |
++		SUNXI_THS_INTS_TDATA_IRQ_0 |
++		SUNXI_THS_INTS_TDATA_IRQ_1 |
++		SUNXI_THS_INTS_TDATA_IRQ_2 |
++		SUNXI_THS_INTS_ALARM_OFF_0 |
++		SUNXI_THS_INTS_ALARM_OFF_1 |
++		SUNXI_THS_INTS_ALARM_OFF_2,
++	.irq_control_map = SUNXI_THS_INTC_TDATA_IRQ_EN0 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN1 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN2 |
++		SUNXI_THS_TEMP_PERIOD(0x7),
+ };
+ 
+ struct sun4i_gpadc_iio {
+@@ -100,6 +136,12 @@
+ 	atomic_t			ignore_temp_data_irq;
+ 	const struct gpadc_data		*data;
+ 	bool				no_irq;
++	struct clk			*bus_clk;
++	struct clk			*mod_clk;
++	struct reset_control		*reset;
++	int				sensor_id;
++	u32				calibration_data[2];
++	bool				has_calibration_data[2];
+ 	/* prevents concurrent reads of temperature and ADC */
+ 	struct mutex			mutex;
+ 	struct thermal_zone_device	*tzd;
+@@ -267,14 +309,15 @@
+ 	return sun4i_gpadc_read(indio_dev, channel, val, info->fifo_data_irq);
+ }
+ 
+-static int sun4i_gpadc_temp_read(struct iio_dev *indio_dev, int *val)
++static int sun4i_gpadc_temp_read(struct iio_dev *indio_dev, int *val,
++				int sensor)
+ {
+ 	struct sun4i_gpadc_iio *info = iio_priv(indio_dev);
+ 
+ 	if (info->no_irq) {
+ 		pm_runtime_get_sync(indio_dev->dev.parent);
+ 
+-		regmap_read(info->regmap, SUN4I_GPADC_TEMP_DATA, val);
++		regmap_read(info->regmap, info->data->temp_data[sensor], val);
+ 
+ 		pm_runtime_mark_last_busy(indio_dev->dev.parent);
+ 		pm_runtime_put_autosuspend(indio_dev->dev.parent);
+@@ -282,6 +315,11 @@
+ 		return 0;
+ 	}
+ 
++	if (info->data->support_irq) {
++		regmap_read(info->regmap, info->data->temp_data[sensor], val);
++		return 0;
++	}
++
+ 	return sun4i_gpadc_read(indio_dev, 0, val, info->temp_data_irq);
+ }
+ 
+@@ -321,7 +369,7 @@
+ 			ret = sun4i_gpadc_adc_read(indio_dev, chan->channel,
+ 						   val);
+ 		else
+-			ret = sun4i_gpadc_temp_read(indio_dev, val);
++			ret = sun4i_gpadc_temp_read(indio_dev, val, 0);
+ 
+ 		if (ret)
+ 			return ret;
+@@ -379,10 +427,19 @@
+ 	return IRQ_HANDLED;
+ }
+ 
+-static int sun4i_gpadc_runtime_suspend(struct device *dev)
++static irqreturn_t sunxi_irq_thread(int irq, void *data)
+ {
+-	struct sun4i_gpadc_iio *info = iio_priv(dev_get_drvdata(dev));
++	struct sun4i_gpadc_iio *info = data;
+ 
++	regmap_write(info->regmap, SUNXI_THS_STAT, info->data->irq_clear_map);
++
++	thermal_zone_device_update(info->tzd, THERMAL_EVENT_TEMP_SAMPLE);
++
++	return IRQ_HANDLED;
++}
++
++static int sun4i_gpadc_sample_end(struct sun4i_gpadc_iio *info)
++{
+ 	/* Disable the ADC on IP */
+ 	regmap_write(info->regmap, SUN4I_GPADC_CTRL1, 0);
+ 	/* Disable temperature sensor on IP */
+@@ -391,19 +448,51 @@
+ 	return 0;
+ }
+ 
+-static int sun4i_gpadc_runtime_resume(struct device *dev)
++static int sunxi_ths_sample_end(struct sun4i_gpadc_iio *info)
++{
++	/* Disable ths interrupt*/
++	regmap_write(info->regmap, SUNXI_THS_INTC, 0x0);
++	/* Disable temperature sensor */
++	regmap_write(info->regmap, SUNXI_THS_CTRL2, 0x0);
++
++	return 0;
++}
++
++static int sun4i_gpadc_runtime_suspend(struct device *dev)
+ {
+ 	struct sun4i_gpadc_iio *info = iio_priv(dev_get_drvdata(dev));
+ 
++	if (info->data->has_mod_clk)
++		clk_disable(info->mod_clk);
++
++	if (info->data->has_bus_clk)
++		clk_disable(info->bus_clk);
++
++	return info->data->sample_end(info);
++}
++
++static void sunxi_calibrate(struct sun4i_gpadc_iio *info)
++{
++	if (info->has_calibration_data[0])
++		regmap_write(info->regmap, SUNXI_THS_CDATA_0_1,
++			info->calibration_data[0]);
++
++	if (info->has_calibration_data[1])
++		regmap_write(info->regmap, SUNXI_THS_CDATA_2_3,
++			info->calibration_data[1]);
++}
++
++static int sun4i_gpadc_sample_start(struct sun4i_gpadc_iio *info)
++{
+ 	/* clkin = 6MHz */
+ 	regmap_write(info->regmap, SUN4I_GPADC_CTRL0,
+ 		     SUN4I_GPADC_CTRL0_ADC_CLK_DIVIDER(2) |
+ 		     SUN4I_GPADC_CTRL0_FS_DIV(7) |
+-		     SUN4I_GPADC_CTRL0_T_ACQ(63));
++		     SUNXI_THS_ACQ0(63));
+ 	regmap_write(info->regmap, SUN4I_GPADC_CTRL1, info->data->tp_mode_en);
+ 	regmap_write(info->regmap, SUN4I_GPADC_CTRL3,
+-		     SUN4I_GPADC_CTRL3_FILTER_EN |
+-		     SUN4I_GPADC_CTRL3_FILTER_TYPE(1));
++		     SUNXI_THS_FILTER_EN |
++		     SUNXI_THS_FILTER_TYPE(1));
+ 	/* period = SUN4I_GPADC_TPR_TEMP_PERIOD * 256 * 16 / clkin; ~0.6s */
+ 	regmap_write(info->regmap, SUN4I_GPADC_TPR,
+ 		     SUN4I_GPADC_TPR_TEMP_ENABLE |
+@@ -412,12 +461,60 @@
+ 	return 0;
+ }
+ 
++static int sunxi_ths_sample_start(struct sun4i_gpadc_iio *info)
++{
++	u32 value;
++	sunxi_calibrate(info);
++
++	if (info->data->ctrl0_map)
++		regmap_write(info->regmap, SUNXI_THS_CTRL0,
++			info->data->ctrl0_map);
++
++	regmap_write(info->regmap, SUNXI_THS_CTRL2,
++		info->data->ctrl2_map);
++
++	regmap_write(info->regmap, SUNXI_THS_STAT,
++			info->data->irq_clear_map);
++
++	regmap_write(info->regmap, SUNXI_THS_FILTER,
++		info->data->filter_map);
++
++	regmap_write(info->regmap, SUNXI_THS_INTC,
++		info->data->irq_control_map);
++
++	regmap_read(info->regmap, SUNXI_THS_CTRL2, &value);
++
++	regmap_write(info->regmap, SUNXI_THS_CTRL2,
++		info->data->sensor_en_map | value);
++
++	return 0;
++}
++
++static int sun4i_gpadc_runtime_resume(struct device *dev)
++{
++	struct sun4i_gpadc_iio *info = iio_priv(dev_get_drvdata(dev));
++
++	if (info->data->has_mod_clk)
++		clk_enable(info->mod_clk);
++
++	if (info->data->has_bus_clk)
++		clk_enable(info->bus_clk);
++
++	return info->data->sample_start(info);
++}
++
+ static int sun4i_gpadc_get_temp(void *data, int *temp)
+ {
+ 	struct sun4i_gpadc_iio *info = data;
+ 	int val, scale, offset;
+ 
+-	if (sun4i_gpadc_temp_read(info->indio_dev, &val))
++	if (sun4i_gpadc_temp_read(info->indio_dev, &val, info->sensor_id))
++		return -ETIMEDOUT;
++
++	/* Ignore first sample which is always zero. 0 is either too
++	 * cold or too hot, so we can safely ignore it
++	 */
++	if (val == 0)
+ 		return -ETIMEDOUT;
+ 
+ 	sun4i_gpadc_temp_scale(info->indio_dev, &scale);
+@@ -489,6 +528,26 @@
+ 		.compatible = "allwinner,sun8i-a33-ths",
+ 		.data = &sun8i_a33_gpadc_data,
+ 	},
++	{
++		.compatible = "allwinner,sun8i-h3-ths",
++		.data = &sun8i_h3_ths_data,
++	},
++	{
++		.compatible = "allwinner,sun8i-a83t-ths",
++		.data = &sun8i_a83t_ths_data,
++	},
++	{
++		.compatible = "allwinner,sun50i-h6-ths",
++		.data = &sun50i_h5_ths_data,
++	},
++	{
++		.compatible = "allwinner,sun9i-a80-ths",
++		.data = &sun9i_a80_ths_data,
++	},
++	{
++		.compatible = "allwinner,sun50i-a64-ths",
++		.data = &sun50i_a64_ths_data,
++	},
+ 	{ /* sentinel */ }
+ };
+ 
+@@ -499,12 +558,32 @@
+ 	struct resource *mem;
+ 	void __iomem *base;
+ 	int ret;
++	struct nvmem_cell *cell;
++	ssize_t cell_size;
++	u64 *cell_data;
++	int irq;
+ 
+ 	info->data = of_device_get_match_data(&pdev->dev);
+ 	if (!info->data)
+ 		return -ENODEV;
+ 
+-	info->no_irq = true;
++	if (info->data->support_irq) {
++		/* only the new versions of ths support right now irqs */
++		irq = platform_get_irq(pdev, 0);
++		if (irq < 0) {
++			dev_err(&pdev->dev, "failed to get IRQ: %d\n", irq);
++			return irq;
++		}
++
++		ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
++				sunxi_irq_thread, IRQF_ONESHOT,
++				dev_name(&pdev->dev), info);
++		if (ret)
++			return ret;
++
++	} else
++		info->no_irq = true;
++
+ 	indio_dev->num_channels = ARRAY_SIZE(sun8i_a33_gpadc_channels);
+ 	indio_dev->channels = sun8i_a33_gpadc_channels;
+ 
+@@ -513,6 +562,35 @@
+ 	if (IS_ERR(base))
+ 		return PTR_ERR(base);
+ 
++	info->has_calibration_data[0] = false;
++	info->has_calibration_data[1] = false;
++
++	if (!info->data->supports_nvmem)
++		goto no_nvmem;
++
++	cell = devm_nvmem_cell_get(&pdev->dev, "calibration");
++	if (IS_ERR(cell)) {
++		if (PTR_ERR(cell) == -EPROBE_DEFER)
++			return PTR_ERR(cell);
++	} else {
++		cell_data = (u64 *)nvmem_cell_read(cell, &cell_size);
++		devm_nvmem_cell_put(&pdev->dev, cell);
++		if (cell_size <= 4) {
++			info->has_calibration_data[0] = true;
++			info->calibration_data[0] = be32_to_cpu(cell_data[0] &
++					GENMASK(31, 0));
++		} else if (cell_size <= 8) {
++			info->has_calibration_data[0] = true;
++			info->calibration_data[0] = be32_to_cpu(cell_data[0] &
++					GENMASK(31, 0));
++			info->has_calibration_data[1] = true;
++			info->calibration_data[1] = be32_to_cpu(
++					(cell_data[0] >> 32) & GENMASK(31, 0));
++		}
++	}
++
++no_nvmem:
++
+ 	info->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+ 					     &sun4i_gpadc_regmap_config);
+ 	if (IS_ERR(info->regmap)) {
+@@ -521,10 +589,61 @@
+ 		return ret;
+ 	}
+ 
++	if (info->data->has_bus_rst) {
++		info->reset = devm_reset_control_get(&pdev->dev, NULL);
++		if (IS_ERR(info->reset)) {
++			ret = PTR_ERR(info->reset);
++			return ret;
++		}
++
++		ret = reset_control_deassert(info->reset);
++		if (ret)
++			return ret;
++	}
++
++	if (info->data->has_bus_clk) {
++		info->bus_clk = devm_clk_get(&pdev->dev, "bus");
++		if (IS_ERR(info->bus_clk)) {
++			ret = PTR_ERR(info->bus_clk);
++			goto assert_reset;
++		}
++
++		ret = clk_prepare_enable(info->bus_clk);
++		if (ret)
++			goto assert_reset;
++	}
++
++	if (info->data->has_mod_clk) {
++		info->mod_clk = devm_clk_get(&pdev->dev, "mod");
++		if (IS_ERR(info->mod_clk)) {
++			ret = PTR_ERR(info->mod_clk);
++			goto disable_bus_clk;
++		}
++
++		/* Running at 6MHz */
++		ret = clk_set_rate(info->mod_clk, 4000000);
++		if (ret)
++			goto disable_bus_clk;
++
++		ret = clk_prepare_enable(info->mod_clk);
++		if (ret)
++			goto disable_bus_clk;
++	}
++
+ 	if (IS_ENABLED(CONFIG_THERMAL_OF))
+ 		info->sensor_device = &pdev->dev;
+ 
+ 	return 0;
++
++disable_bus_clk:
++	if (info->data->has_bus_clk)
++		clk_disable_unprepare(info->bus_clk);
++
++assert_reset:
++	if (info->data->has_bus_rst)
++		reset_control_assert(info->reset);
++
++	return ret;
+ }
+ 
+ static int sun4i_gpadc_probe_mfd(struct platform_device *pdev,
+@@ -608,7 +650,7 @@
+ {
+ 	struct sun4i_gpadc_iio *info;
+ 	struct iio_dev *indio_dev;
+-	int ret;
++	int ret, i;
+ 
+ 	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*info));
+ 	if (!indio_dev)
+@@ -634,16 +670,21 @@
+ 	if (ret)
+ 		return ret;
+ 
+-	pm_runtime_set_autosuspend_delay(&pdev->dev,
+-					 SUN4I_GPADC_AUTOSUSPEND_DELAY);
+-	pm_runtime_use_autosuspend(&pdev->dev);
+-	pm_runtime_set_suspended(&pdev->dev);
+-	pm_runtime_enable(&pdev->dev);
++	if (!info->data->support_irq) {
++		pm_runtime_set_autosuspend_delay(&pdev->dev,
++						 SUN4I_GPADC_AUTOSUSPEND_DELAY);
++		pm_runtime_use_autosuspend(&pdev->dev);
++		pm_runtime_set_suspended(&pdev->dev);
++		pm_runtime_enable(&pdev->dev);
++	}
+ 
+ 	if (IS_ENABLED(CONFIG_THERMAL_OF)) {
+-		info->tzd = thermal_zone_of_sensor_register(info->sensor_device,
+-							    0, info,
+-							    &sun4i_ts_tz_ops);
++		for (i = 0; i < info->data->sensor_count; i++) {
++			info->sensor_id = i;
++			info->tzd = thermal_zone_of_sensor_register(
++					info->sensor_device,
++					i, info, &sun4i_ts_tz_ops);
++		}
+ 		/*
+ 		 * Do not fail driver probing when failing to register in
+ 		 * thermal because no thermal DT node is found.
+@@ -656,6 +680,9 @@
+ 		}
+ 	}
+ 
++	if (info->data->support_irq)
++		info->data->sample_start(info);
++
+ 	ret = devm_iio_device_register(&pdev->dev, indio_dev);
+ 	if (ret < 0) {
+ 		dev_err(&pdev->dev, "could not register the device\n");
+@@ -685,11 +720,23 @@
+ 	if (!IS_ENABLED(CONFIG_THERMAL_OF))
+ 		return 0;
+ 
++	if (info->data->support_irq)
++		info->data->sample_end(info);
++
+ 	thermal_zone_of_sensor_unregister(info->sensor_device, info->tzd);
+ 
+ 	if (!info->no_irq)
+ 		iio_map_array_unregister(indio_dev);
+ 
++	if (info->data->has_mod_clk)
++		clk_disable_unprepare(info->mod_clk);
++
++	if (info->data->has_bus_clk)
++		clk_disable_unprepare(info->bus_clk);
++
++	if (info->data->has_bus_rst)
++		reset_control_assert(info->reset);
++
+ 	return 0;
+ }
+ 
--- a/target/linux/sunxi/patches-5.4/207-add5-sunxi-ths_gpadc_linux.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/207-add5-sunxi-ths_gpadc_linux.patch	2021-05-09 17:02:30.546713263 +0300
@@ -0,0 +1,107 @@
+--- a/drivers/iio/adc/Kconfig
++++ b/drivers/iio/adc/Kconfig
+@@ -859,7 +890,7 @@
+ config SUN4I_GPADC
+ 	tristate "Support for the Allwinner SoCs GPADC"
+ 	depends on IIO
+-	depends on MFD_SUN4I_GPADC || MACH_SUN8I
++	depends on MFD_SUN4I_GPADC || MACH_SUN8I || MACH_SUN50I || MACH_SUN9I
+ 	depends on THERMAL || !THERMAL_OF
+ 	select REGMAP_IRQ
+ 	help
+--- a/include/linux/mfd/sun4i-gpadc.h
++++ b/include/linux/mfd/sun4i-gpadc.h
+@@ -14,7 +17,6 @@
+ #define SUN4I_GPADC_CTRL0_ADC_CLK_SELECT		BIT(22)
+ #define SUN4I_GPADC_CTRL0_ADC_CLK_DIVIDER(x)		((GENMASK(1, 0) & (x)) << 20)
+ #define SUN4I_GPADC_CTRL0_FS_DIV(x)			((GENMASK(3, 0) & (x)) << 16)
+-#define SUN4I_GPADC_CTRL0_T_ACQ(x)			(GENMASK(15, 0) & (x))
+ 
+ #define SUN4I_GPADC_CTRL1				0x04
+ 
+@@ -35,9 +37,9 @@
+ #define SUN6I_GPADC_CTRL1_ADC_CHAN_SELECT(x)		(GENMASK(3, 0) & BIT(x))
+ #define SUN6I_GPADC_CTRL1_ADC_CHAN_MASK			GENMASK(3, 0)
+ 
+-/* TP_CTRL1 bits for sun8i SoCs */
+-#define SUN8I_GPADC_CTRL1_CHOP_TEMP_EN			BIT(8)
+-#define SUN8I_GPADC_CTRL1_GPADC_CALI_EN			BIT(7)
++/* TP_CTRL1 bits for A33 */
++#define SUN8I_A33_GPADC_CTRL1_CHOP_TEMP_EN		BIT(8)
++#define SUN8I_A33_GPADC_CTRL1_GPADC_CALI_EN		BIT(7)
+ 
+ #define SUN4I_GPADC_CTRL2				0x08
+ 
+@@ -48,9 +50,6 @@
+ 
+ #define SUN4I_GPADC_CTRL3				0x0c
+ 
+-#define SUN4I_GPADC_CTRL3_FILTER_EN			BIT(2)
+-#define SUN4I_GPADC_CTRL3_FILTER_TYPE(x)		(GENMASK(1, 0) & (x))
+-
+ #define SUN4I_GPADC_TPR					0x18
+ 
+ #define SUN4I_GPADC_TPR_TEMP_ENABLE			BIT(16)
+@@ -87,6 +96,62 @@
+ /* 10s delay before suspending the IP */
+ #define SUN4I_GPADC_AUTOSUSPEND_DELAY			10000
+ 
++/* SUNXI_THS COMMON REGISTERS + DEFINES */
++#define SUNXI_THS_CTRL0					0x00
++#define SUNXI_THS_CTRL2					0x40
++#define SUNXI_THS_INTC					0x44
++#define SUNXI_THS_STAT					0x48
++#define SUNXI_THS_FILTER				0x70
++#define SUNXI_THS_CDATA_0_1				0x74
++#define SUNXI_THS_CDATA_2_3				0x78
++#define SUNXI_THS_TDATA0				0x80
++#define SUNXI_THS_TDATA1				0x84
++#define SUNXI_THS_TDATA2				0x88
++#define SUNXI_THS_TDATA3				0x8c
++
++#define SUNXI_THS_FILTER_EN				BIT(2)
++#define SUNXI_THS_FILTER_TYPE(x)			(GENMASK(1, 0) & (x))
++#define SUNXI_THS_ACQ0(x)				(GENMASK(15, 0) & (x))
++#define SUNXI_THS_ACQ1(x)				(GENMASK(31, 16) & ((x) << 16))
++
++#define SUNXI_THS_TEMP_SENSE_EN0			BIT(0)
++#define SUNXI_THS_TEMP_SENSE_EN1			BIT(1)
++#define SUNXI_THS_TEMP_SENSE_EN2			BIT(2)
++#define SUNXI_THS_TEMP_SENSE_EN3			BIT(3)
++
++#define SUNXI_THS_TEMP_PERIOD(x)			(GENMASK(31, 12) & ((x) << 12))
++
++#define SUNXI_THS_INTS_ALARM_OFF_2			BIT(14)
++#define SUNXI_THS_INTS_ALARM_OFF_1			BIT(13)
++#define SUNXI_THS_INTS_ALARM_OFF_0			BIT(12)
++#define SUNXI_THS_INTS_TDATA_IRQ_3			BIT(11)
++#define SUNXI_THS_INTS_TDATA_IRQ_2			BIT(10)
++#define SUNXI_THS_INTS_TDATA_IRQ_1			BIT(9)
++#define SUNXI_THS_INTS_TDATA_IRQ_0			BIT(8)
++#define SUNXI_THS_INTS_SHUT_INT_3			BIT(7)
++#define SUNXI_THS_INTS_SHUT_INT_2			BIT(6)
++#define SUNXI_THS_INTS_SHUT_INT_1			BIT(5)
++#define SUNXI_THS_INTS_SHUT_INT_0			BIT(4)
++#define SUNXI_THS_INTS_ALARM_INT_3			BIT(3)
++#define SUNXI_THS_INTS_ALARM_INT_2			BIT(2)
++#define SUNXI_THS_INTS_ALARM_INT_1			BIT(1)
++#define SUNXI_THS_INTS_ALARM_INT_0			BIT(0)
++
++#define SUNXI_THS_INTC_TDATA_IRQ_EN3			BIT(11)
++#define SUNXI_THS_INTC_TDATA_IRQ_EN2			BIT(10)
++#define SUNXI_THS_INTC_TDATA_IRQ_EN1			BIT(9)
++#define SUNXI_THS_INTC_TDATA_IRQ_EN0			BIT(8)
++#define SUNXI_THS_INTC_SHUT_INT_EN3			BIT(7)
++#define SUNXI_THS_INTC_SHUT_INT_EN2			BIT(6)
++#define SUNXI_THS_INTC_SHUT_INT_EN1			BIT(5)
++#define SUNXI_THS_INTC_SHUT_INT_EN0			BIT(4)
++#define SUNXI_THS_INTC_ALARM_INT_EN3			BIT(3)
++#define SUNXI_THS_INTC_ALARM_INT_EN2			BIT(2)
++#define SUNXI_THS_INTC_ALARM_INT_EN1			BIT(1)
++#define SUNXI_THS_INTC_ALARM_INT_EN0			BIT(0)
++
++#define MAX_SENSOR_COUNT				4
++
+ struct sun4i_gpadc_dev {
+ 	struct device			*dev;
+ 	struct regmap			*regmap;
--- a/target/linux/sunxi/image/cortexa8.mk	2021-04-19 22:10:14.000000000 +0300
+++ b/target/linux/sunxi/image/cortexa8.mk	2021-05-08 21:04:39.779977025 +0300
@@ -11,6 +11,14 @@
 endef
 TARGET_DEVICES += cubietech_a10-cubieboard
 
+define Device/mele_a10-a1000
+  DEVICE_VENDOR := Mele
+  DEVICE_MODEL := A1000
+  DEVICE_PACKAGES:=kmod-ata-sunxi kmod-sun4i-emac kmod-rtc-sunxi
+  SOC := sun4i
+endef
+TARGET_DEVICES += mele_a10-a1000
+
 define Device/linksprite_a10-pcduino
   DEVICE_VENDOR := LinkSprite
   DEVICE_MODEL := pcDuino
--- a/target/linux/sunxi/patches-5.4/210-add-spdif-PA17-red_led-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/210-add-spdif-PA17-red_led-opi-zero.patch	2021-05-08 21:04:39.779977025 +0300
@@ -0,0 +1,40 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts	2020-01-29 16:02:39.000000000 +0200
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts	2020-02-01 11:37:12.000000000 +0200
+@@ -123,6 +150,24 @@
+ 		reset-gpios = <&r_pio 0 7 GPIO_ACTIVE_LOW>;
+ 		post-power-on-delay-ms = <200>;
+ 	};
++
++	sound_spdif {
++		compatible = "simple-audio-card";
++		simple-audio-card,name = "On-board SPDIF";
++
++		simple-audio-card,cpu {
++			sound-dai = <&spdif>;
++		};
++
++		simple-audio-card,codec {
++			sound-dai = <&spdif_out>;
++		};
++	};
++
++	spdif_out: spdif-out {
++		#sound-dai-cells = <0>;
++		compatible = "linux,spdif-dit";
++	};
+ };
+ 
+ &cpu0 {
+@@ -244,6 +310,12 @@
+ 	pinctrl-0 = <&uart2_pins>;
+ 	status = "disabled";
+ };
++
++&spdif {
++	pinctrl-names = "default";
++	pinctrl-0 = <&spdif_tx_pin>;
++	status = "disabled";
++};
+ 
+ &usb_otg {
+ 	dr_mode = "peripheral";
--- a/target/linux/sunxi/patches-5.4/211-add-button-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/211-add-button-opi-zero.patch	2021-05-08 21:04:39.779977025 +0300
@@ -0,0 +1,109 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts	2020-01-29 16:02:39.000000000 +0200
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts	2020-02-01 11:37:12.000000000 +0200
+@@ -92,6 +120,76 @@
+ 		pinctrl-0 = <&w1_pins>;
+ 		status = "disabled";
+ 	};
++
++	gpio-keys-user {
++		compatible = "gpio-keys";
++		pinctrl-names = "default";
++		pinctrl-0 = <&gpio_keys>;
++		status = "disabled";
++
++		g-keys_volup {
++			label = "GPIO KEY_VOLUMEUP";
++			linux,code = <115>; /* 115, see /usr/include/linux/input-event-codes.h */
++			gpios = <&pio 0 16 GPIO_ACTIVE_LOW>; /* PA16 GPIO_ACTIVE_LOW */
++		};
++
++		g-keys_voldown {
++			label = "GPIO KEY_VOLUMEDOWN";
++			linux,code = <114>; /* 114, see /usr/include/linux/input-event-codes.h */
++			gpios = <&pio 0 15 GPIO_ACTIVE_LOW>; /* PA15 GPIO_ACTIVE_LOW */
++		};
++
++		g-keys_power {
++			label = "GPIO KEY_POWER";
++			linux,code = <116>; /* 116, see /usr/include/linux/input-event-codes.h */
++			gpios = <&pio 0 14 GPIO_ACTIVE_LOW>; /* PA14 GPIO_ACTIVE_LOW */
++		};
++
++		g-keys_chanup {
++			label = "GPIO KEY_CHANNELUP";
++			linux,code = <402>; /* 402, see /usr/include/linux/input-event-codes.h */
++			gpios = <&pio 0 13 GPIO_ACTIVE_LOW>; /* PA13 GPIO_ACTIVE_LOW */
++		};
++
++		g-keys_chandown {
++			label = "GPIO KEY_CHANNELDOWN";
++			linux,code = <403>; /* 403, see /usr/include/linux/input-event-codes.h */
++			gpios = <&pio 0 2 GPIO_ACTIVE_LOW>; /* PA2 GPIO_ACTIVE_LOW */
++		};
++	};
++
++	rotary_button {
++		compatible = "gpio-keys";
++		pinctrl-names = "default";
++		pinctrl-0 = <&pinctrl_button>;
++		status = "disabled";
++
++		rotary_button_enter {
++			label = "ENTER";
++			linux,code = <99>; /* KEY_SYSRQ - see linux/input.h */
++			gpios = <&pio 0 0 GPIO_ACTIVE_LOW>; /* PA0 GPIO_ACTIVE_LOW */
++		};
++	};
++
++	rotary_axis {
++		/* https://mchehab.fedorapeople.org/kernel_docs/input/devices/rotary-encoder.html */
++		compatible = "rotary-encoder";
++		pinctrl-names = "default";
++		pinctrl-0 = <&pinctrl_rotary>;
++		gpios = <&pio 0 1 GPIO_ACTIVE_LOW>, <&pio 0 3 GPIO_ACTIVE_LOW>; /* PA1 PA3 GPIO_ACTIVE_LOW */
++		linux,axis = <1>; /* REL_Y */
++		rotary-encoder,relative-axis;
++		rotary-encoder,half-period;
++		status = "disabled";
++	};
++
++	pps {
++		compatible = "pps-gpio";
++		pinctrl-names = "default";
++		pinctrl-0 = <&pps_pins>;
++		gpios = <&pio 0 7 0>; /* PA7 */
++		status = "disabled";
++	};
+ 
+ 	reg_vcc_wifi: reg_vcc_wifi {
+ 		compatible = "regulator-fixed";
+@@ -225,6 +299,29 @@
+ 		drive = <SUN4I_PINCTRL_10_MA>;
+ 		pull = <SUN4I_PINCTRL_NO_PULL>;
+ 	};
++
++	gpio_keys: gpio_keys {
++		pins = "PA13","PA14","PA15","PA16","PA2";
++		function = "gpio_in";
++		bias-pull-up;
++	};
++
++	pinctrl_button: pinctrl_button {
++		pins = "PA0";
++		function = "gpio_in";
++		bias-pull-up;
++	};
++
++	pinctrl_rotary: pinctrl_rotary {
++		pins = "PA1","PA3";
++		function = "gpio_in";
++		bias-pull-up;
++	};
++
++	pps_pins: pps_pins {
++		pins = "PA7";
++		function = "gpio_in";
++	};
+ };
+ 
+ &pwm {
--- a/target/linux/sunxi/patches-5.4/212-add-spi-flash-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/212-add-spi-flash-opi-zero.patch	2021-05-08 21:04:39.779977025 +0300
@@ -0,0 +1,48 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -60,6 +70,7 @@
+ 		/* ethernet0 is the H3 emac, defined in sun8i-h3.dtsi */
+ 		ethernet0 = &emac;
+ 		ethernet1 = &xr819;
++		spi0 = &spi0;
+ 	};
+ 
+ 	chosen {
+@@ -327,7 +400,7 @@
+ 
+ &spi0 {
+ 	/* Disable SPI NOR by default: it optional on Orange Pi Zero boards */
+-	status = "disabled";
++	status = "okay";
+ 
+ 	flash@0 {
+ 		#address-cells = <1>;
+@@ -335,6 +400,28 @@
+ 		compatible = "mxicy,mx25l1606e", "winbond,w25q128";
+ 		reg = <0>;
+ 		spi-max-frequency = <40000000>;
++
++		partitions: partitions {
++			compatible = "fixed-partitions";
++			#address-cells = <0x01>;
++			#size-cells = <0x01>;
++
++			partition@0 {
++				label = "uboot";
++				reg = <0x0 0x80000>;
++			};
++
++			partition@80000 {
++				label = "dtb";
++				reg = <0x80000 0x10000>;
++			};
++
++			partition@90000 {
++				compatible = "denx,uimage";
++				label = "firmware";
++				reg = <0x90000 0xf70000>;
++			};
++		};
+ 	};
+ };
+ 
--- a/target/linux/sunxi/patches-5.4/213-add-i2c-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/213-add-i2c-opi-zero.patch	2021-05-08 21:04:39.779977025 +0300
@@ -0,0 +1,11 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -61,6 +70,8 @@
+ 		ethernet0 = &emac;
+ 		ethernet1 = &xr819;
+ 		spi0 = &spi0;
++		i2c0 = &i2c0;
++		i2c1 = &i2c1;
+ 	};
+ 
+ 	chosen {
--- a/target/linux/sunxi/patches-5.4/213-dts-add-orangepi-zero-lts.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/213-dts-add-orangepi-zero-lts.patch	2021-05-09 22:18:28.703644760 +0300
@@ -0,0 +1,31 @@
+--- a/arch/arm/boot/dts/Makefile
++++ b/arch/arm/boot/dts/Makefile
+@@ -1099,6 +1110,7 @@ dtb-$(CONFIG_MACH_SUN8I) += \
+ 	sun8i-h2-plus-bananapi-m2-zero.dtb \
+ 	sun8i-h2-plus-libretech-all-h3-cc.dtb \
+ 	sun8i-h2-plus-orangepi-r1.dtb \
++	sun8i-h2-plus-orangepi-zero-lts.dtb \
+ 	sun8i-h2-plus-orangepi-zero.dtb \
+ 	sun8i-h3-bananapi-m2-plus.dtb \
+ 	sun8i-h3-bananapi-m2-plus-v1.2.dtb \
+--- /dev/null
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero-lts.dts
+@@ -0,0 +1,18 @@
++
++/* Orange Pi Zero Lts is based on Orange Pi Zero design */
++#include "sun8i-h2-plus-orangepi-zero.dts"
++
++/ {
++	model = "Xunlong Orange Pi Zero Lts";
++	compatible = "xunlong,orangepi-zero-lts", "allwinner,sun8i-h2-plus";
++};
++
++&cpu_hot_trip {
++	temperature = <32500>; /* ~65°C */
++	hysteresis = <1000>;
++};
++
++&cpu_very_hot_trip {
++	temperature = <45000>; /* ~90°C */
++	hysteresis = <1000>;
++};
--- a/target/linux/sunxi/patches-5.4/214-usb_otg-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/214-usb_otg-opi-zero.patch	2021-05-08 21:04:39.779977025 +0300
@@ -0,0 +1,11 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -388,7 +402,7 @@
+ };
+ 
+ &usb_otg {
+-	dr_mode = "peripheral";
++	dr_mode = "otg";
+ 	status = "okay";
+ };
+ 
--- a/target/linux/sunxi/patches-5.4/215-pinctrl_wifi-wake_r-wifi-rst_opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-5.4/215-pinctrl_wifi-wake_r-wifi-rst_opi-zero.patch	2021-05-09 17:03:26.134686669 +0300
@@ -0,0 +1,44 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -193,6 +210,8 @@
+ 
+ 	wifi_pwrseq: wifi_pwrseq {
+ 		compatible = "mmc-pwrseq-simple";
++		pinctrl-names = "default";
++		pinctrl-0 = <&r_wifi_rst>;
+ 		reset-gpios = <&r_pio 0 7 GPIO_ACTIVE_LOW>;
+ 		post-power-on-delay-ms = <200>;
+ 	};
+@@ -257,11 +270,20 @@
+ 	xr819: sdio_wifi@1 {
+ 		reg = <1>;
+ 		compatible = "xradio,xr819";
++		pinctrl-names = "default";
++		pinctrl-0 = <&wifi_wake>;
+ 		interrupt-parent = <&pio>;
+ 		interrupts = <6 10 IRQ_TYPE_EDGE_RISING>;
+ 		interrupt-names = "host-wake";
+ 	};
+ };
++
++&r_pio {
++	r_wifi_rst: r-wifi-rst {
++		pins = "PL7";
++		function = "gpio_out";
++	};
++};
+ 
+ &ohci0 {
+ 	status = "okay";
+@@ -321,6 +342,11 @@
+ 		pins = "PA7";
+ 		function = "gpio_in";
+ 	};
++
++	wifi_wake: wifi-wake {
++		pins = "PG10";
++		function = "gpio_in";
++	};
+ };
+ 
+ &pwm {
--- a/target/linux/sunxi/base-files/etc/board.d/01_leds	2021-04-19 22:10:14.000000000 +0300
+++ b/target/linux/sunxi/base-files/etc/board.d/01_leds	2021-05-08 21:04:39.783976932 +0300
@@ -12,6 +12,9 @@
 	ucidef_set_led_netdev "wan" "WAN" "nanopi:green:wan" "eth0"
 	ucidef_set_led_netdev "lan" "LAN" "nanopi:green:lan" "eth1"
 	;;
+xunlong,orangepi-zero|xunlong,orangepi-zero-lts)
+	ucidef_set_led_netdev "lan" "LAN" "orangepi:red:status" "eth0"
+	;;
 esac
 
 board_config_flush
--- a/target/linux/sunxi/Makefile	2021-04-19 22:10:14.000000000 +0300
+++ b/target/linux/sunxi/Makefile	2021-05-21 12:02:10.683190924 +0300
@@ -8,7 +8,7 @@
 BOARD:=sunxi
 BOARDNAME:=Allwinner A1x/A20/A3x/H3/H5/R40
 FEATURES:=fpu usb ext4 display rtc squashfs
-SUBTARGETS:=cortexa8 cortexa7 cortexa53
+SUBTARGETS:=cortexa8 cortexa7 cortexa53 cortexspia7
 
 KERNEL_PATCHVER:=5.4
 KERNEL_TESTING_PATCHVER:=5.4
--- a/target/linux/sunxi/cortexspia7/config-5.4	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/cortexspia7/config-5.4	2021-05-21 12:15:10.306325751 +0300
@@ -0,0 +1,24 @@
+CONFIG_ARCH_32BIT_OFF_T=y
+CONFIG_ARCH_HAS_BINFMT_FLAT=y
+CONFIG_ARCH_HAS_TEARDOWN_DMA_OPS=y
+CONFIG_BINFMT_FLAT_ARGVP_ENVP_ON_STACK=y
+CONFIG_COMPAT_32BIT_TIME=y
+CONFIG_DWMAC_SUN8I=y
+# CONFIG_MACH_SUN4I is not set
+# CONFIG_MACH_SUN5I is not set
+CONFIG_MDIO_BUS_MUX=y
+# CONFIG_PINCTRL_SUN50I_A64 is not set
+# CONFIG_PINCTRL_SUN50I_A64_R is not set
+# CONFIG_PINCTRL_SUN50I_H5 is not set
+# CONFIG_PINCTRL_SUN50I_H6 is not set
+# CONFIG_PINCTRL_SUN50I_H6_R is not set
+CONFIG_UNWINDER_ARM=y
+CONFIG_MTD=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_SPLIT_FIRMWARE=y
+CONFIG_MTD_SPLIT_UIMAGE_FW=y
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_IMPA7 is not set
+CONFIG_MTD_SPLIT_SUPPORT=y
+CONFIG_MULTI_IRQ_HANDLER=y
--- a/target/linux/sunxi/cortexspia7/target.mk	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/cortexspia7/target.mk	2021-05-21 12:16:08.512316695 +0300
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Copyright (C) 2017 Hauke Mehrtens
+
+include $(TOPDIR)/rules.mk
+
+BOARDNAME:=Allwinner /H2+spi/H3spi
+CPU_TYPE:=cortex-a7
+CPU_SUBTYPE:=neon-vfpv4
--- a/target/linux/sunxi/image/cortexspia7.mk	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/image/cortexspia7.mk	2021-05-21 12:07:09.276248751 +0300
@@ -0,0 +1,78 @@
+
+define Build/append-uboot
+       dd if=$(STAGING_DIR_IMAGE)/$(DEVICE_NAME)-u-boot-with-spl.bin >> $@
+endef
+
+define Build/append-scr
+       dd if=$(STAGING_DIR_IMAGE)/$(DEVICE_NAME)-boot.scr >> $@
+endef
+
+define Build/append-dtb
+       dd if=$(DTS_DIR)/$(SUNXI_DTS).dtb >> $@
+endef
+
+define Device/xunlong_orangepi-zero-lts
+  DEVICE_VENDOR := Xunlong
+  DEVICE_MODEL := Orange Pi Zero Lts
+  FILESYSTEMS := squashfs
+  IMAGES := sysupgrade.bin dtb boot.bin boot.scr # fullflash.bin
+  FULLFLASH_SIZE := 16384K
+  IMAGE_SIZE := 15808k
+  BOOT_SIZE := 512k
+  DTB_SIZE := 64k
+  BLOCKSIZE := 4k
+  IMAGE/sysupgrade.bin := append-kernel | append-rootfs | pad-rootfs | append-metadata | check-size $$$$(IMAGE_SIZE)
+#  IMAGE/fullflash.bin := append-uboot | pad-to $$$$(BOOT_SIZE) | append-scr | pad-to $$$$(DTB_SIZE) | append-dtb | pad-to $$$$(DTB_SIZE) | \
+#			append-kernel | append-rootfs | pad-rootfs
+  IMAGE/boot.bin := append-uboot | pad-to $$$$(BLOCKSIZE)
+  IMAGE/boot.scr := append-scr | pad-to $$$$(BLOCKSIZE)
+  IMAGE/dtb := append-dtb | pad-to $$$$(BLOCKSIZE)
+  DEVICE_PACKAGES:=kmod-rtc-sunxi kmod-xradio \
+	boot-config
+  SOC := sun8i-h2-plus
+endef
+TARGET_DEVICES += xunlong_orangepi-zero-lts
+
+define Device/xunlong_orangepi-r1
+  DEVICE_VENDOR := Xunlong
+  DEVICE_MODEL := Orange Pi R1
+  FILESYSTEMS := squashfs
+  IMAGES := sysupgrade.bin dtb boot.bin boot.scr # fullflash.bin
+  FULLFLASH_SIZE := 16384K
+  IMAGE_SIZE := 15808k
+  BOOT_SIZE := 512k
+  DTB_SIZE := 64k
+  BLOCKSIZE := 4k
+  IMAGE/sysupgrade.bin := append-kernel | append-rootfs | pad-rootfs | append-metadata | check-size $$$$(IMAGE_SIZE)
+#  IMAGE/fullflash.bin := append-uboot | pad-to $$$$(BOOT_SIZE) | append-scr | pad-to $$$$(DTB_SIZE) | append-dtb | pad-to $$$$(DTB_SIZE) | \
+#			append-kernel | append-rootfs | pad-rootfs
+  IMAGE/boot.bin := append-uboot | pad-to $$$$(BLOCKSIZE)
+  IMAGE/boot.scr := append-scr | pad-to $$$$(BLOCKSIZE)
+  IMAGE/dtb := append-dtb | pad-to $$$$(BLOCKSIZE)
+  DEVICE_PACKAGES:=kmod-rtc-sunxi kmod-usb-net-rtl8152 \
+	boot-config
+  SOC := sun8i-h2-plus
+endef
+TARGET_DEVICES += xunlong_orangepi-r1
+
+define Device/xunlong_orangepi-zero
+  DEVICE_VENDOR := Xunlong
+  DEVICE_MODEL := Orange Pi Zero
+  FILESYSTEMS := squashfs
+  IMAGES := sysupgrade.bin dtb boot.bin boot.scr # fullflash.bin
+  FULLFLASH_SIZE := 16384K
+  IMAGE_SIZE := 15808k
+  BOOT_SIZE := 512k
+  DTB_SIZE := 64k
+  BLOCKSIZE := 4k
+  IMAGE/sysupgrade.bin := append-kernel | append-rootfs | pad-rootfs | append-metadata | check-size $$$$(IMAGE_SIZE)
+#  IMAGE/fullflash.bin := append-uboot | pad-to $$$$(BOOT_SIZE) | append-scr | pad-to $$$$(DTB_SIZE) | append-dtb | pad-to $$$$(DTB_SIZE) | \
+#			append-kernel | append-rootfs | pad-rootfs
+  IMAGE/boot.bin := append-uboot | pad-to $$$$(BLOCKSIZE)
+  IMAGE/boot.scr := append-scr | pad-to $$$$(BLOCKSIZE)
+  IMAGE/dtb := append-dtb | pad-to $$$$(BLOCKSIZE)
+  DEVICE_PACKAGES:=kmod-rtc-sunxi kmod-xradio \
+	boot-config
+  SOC := sun8i-h2-plus
+endef
+TARGET_DEVICES += xunlong_orangepi-zero
--- a/package/boot/uboot-sunxi/Makefile	2021-04-19 22:10:14.000000000 +0300
+++ b/package/boot/uboot-sunxi/Makefile	2021-05-21 12:19:24.875765019 +0300
@@ -95,6 +95,12 @@
   BUILD_DEVICES:=cubietech_a10-cubieboard
 endef
 
+define U-Boot/Mele_A1000
+  BUILD_SUBTARGET:=cortexa8
+  NAME:=Mele A1000
+  BUILD_DEVICES:=mele_a10-a1000
+endef
+
 define U-Boot/Cubieboard2
   BUILD_SUBTARGET:=cortexa7
   NAME:=Cubieboard2
@@ -196,6 +202,33 @@
   BUILD_DEVICES:=xunlong_orangepi-zero
 endef
 
+define U-Boot/orangepi_zero_lts
+  BUILD_SUBTARGET:=cortexa7
+  NAME:=Orange Pi Zero Lts (H2+)
+  BUILD_DEVICES:=xunlong_orangepi-zero-lts
+endef
+
+define U-Boot/orangepi_r1
+  BUILD_SUBTARGET:=cortexspia7
+  NAME:=Orange Pi R1 (H2+)
+  BUILD_DEVICES:=xunlong_orangepi-r1
+  UENV:=spi16mb
+endef
+
+define U-Boot/orangepi_zero
+  BUILD_SUBTARGET:=cortexspia7
+  NAME:=Orange Pi Zero (H2+)
+  BUILD_DEVICES:=xunlong_orangepi-zero
+  UENV:=spi16mb
+endef
+
+define U-Boot/orangepi_zero_lts
+  BUILD_SUBTARGET:=cortexspia7
+  NAME:=Orange Pi Zero Lts (H2+)
+  BUILD_DEVICES:=xunlong_orangepi-zero-lts
+  UENV:=spi16mb
+endef
+
 define U-Boot/orangepi_one
   BUILD_SUBTARGET:=cortexa7
   NAME:=Orange Pi One (H3)
@@ -315,6 +348,7 @@
 	Bananapi_M2_Ultra \
 	Bananapro \
 	Cubieboard \
+	Mele_A1000 \
 	Cubieboard2 \
 	Cubietruck \
 	Hummingbird_A31 \
@@ -333,6 +367,7 @@
 	nanopi_neo2 \
 	nanopi_r1 \
 	orangepi_zero \
+	orangepi_zero_lts \
 	orangepi_r1 \
 	orangepi_one \
 	orangepi_pc \
--- a/package/boot/uboot-sunxi/patches/001-add-distro_bootcmd.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/package/boot/uboot-sunxi/patches/001-add-distro_bootcmd.patch	2021-05-24 11:03:32.067860731 +0300
@@ -0,0 +1,20 @@
+--- a/include/config_distro_bootcmd.h
++++ b/include/config_distro_bootcmd.h
+@@ -477,7 +480,16 @@
+ 	\
+ 	BOOT_TARGET_DEVICES(BOOTENV_DEV)                                  \
+ 	\
+-	"distro_bootcmd=" BOOTENV_SET_SCSI_NEED_INIT                      \
++	"distro_bootcmd="								\
++	"if sf probe 0; then "								\
++		"setenv fdt_high ffffffff;"						\
++		"setenv bootargs console=ttyS0,115200 earlyprintk rootfstype=squashfs	\
++			mtdparts=spi0.0:512k(uboot),64k(dtb),-(firmware);"		\
++		"sf read 0x43000000 0x80000 0x10000;"					\
++		"sf read 0x42000000 0x90000 0x400000;"					\
++		"bootm 0x42000000 - 0x43000000;"					\
++	"fi; "										\
++		BOOTENV_SET_SCSI_NEED_INIT                                \
+ 		BOOTENV_SET_NVME_NEED_INIT                                \
+ 		BOOTENV_SET_IDE_NEED_INIT                                 \
+ 		BOOTENV_SET_VIRTIO_NEED_INIT                              \
--- a/package/boot/uboot-sunxi/patches/001-add-mtd-spi-orangepi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/package/boot/uboot-sunxi/patches/001-add-mtd-spi-orangepi-zero.patch	2021-05-20 23:20:18.798794000 +0300
@@ -0,0 +1,19 @@
+--- a/arch/arm/dts/sun8i-h2-plus-orangepi-zero.dts	2020-04-13 18:02:18.000000000 +0300
++++ b/arch/arm/dts/sun8i-h2-plus-orangepi-zero.dts	2021-02-11 12:02:27.730670592 +0200
+@@ -59,6 +59,7 @@
+ 		/* ethernet0 is the H3 emac, defined in sun8i-h3.dtsi */
+ 		ethernet0 = &emac;
+ 		ethernet1 = &xr819;
++		spi0 = &spi0;
+ 	};
+ 
+ 	chosen {
+@@ -164,7 +165,7 @@
+ 
+ &spi0 {
+ 	/* Disable SPI NOR by default: it optional on Orange Pi Zero boards */
+-	status = "disabled";
++	status = "okay";
+ 
+ 	flash@0 {
+ 		#address-cells = <1>;
--- a/package/boot/uboot-sunxi/patches/001-add-spi-orangepi_r1_defconfig.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/package/boot/uboot-sunxi/patches/001-add-spi-orangepi_r1_defconfig.patch	2021-05-20 15:35:36.906256000 +0300
@@ -0,0 +1,15 @@
+--- a/configs/orangepi_r1_defconfig	2020-04-13 18:02:18.000000000 +0300
++++ b/configs/orangepi_r1_defconfig	2021-02-11 11:56:03.965480643 +0200
+@@ -11,3 +11,12 @@
+ CONFIG_SUN8I_EMAC=y
+ CONFIG_USB_EHCI_HCD=y
+ CONFIG_USB_OHCI_HCD=y
++CONFIG_SPI=y
++CONFIG_SPI_SUNXI=y
++CONFIG_CMD_SF=y
++CONFIG_CMD_SPI=y
++CONFIG_DM_SPI=y
++CONFIG_DM_SPI_FLASH=y
++CONFIG_SPI_FLASH=y
++CONFIG_SPI_FLASH_WINBOND=y
++CONFIG_SPI_FLASH_MACRONIX=y
--- a/package/boot/uboot-sunxi/uEnv-spi16mb.txt	1970-01-01 03:00:00.000000000 +0300
+++ b/package/boot/uboot-sunxi/uEnv-spi16mb.txt	2021-05-22 01:21:32.495318000 +0300
@@ -0,0 +1,7 @@
+setenv fdt_high ffffffff
+setenv bootargs console=ttyS0,115200 earlyprintk rootfstype=squashfs mtdparts=spi0.0:512k(uboot),64k(dtb),-(firmware)
+setenv loadprobe sf probe 0
+setenv loaddtb sf read $fdt_addr_r 0x80000 0x10000
+setenv loadkernel sf read $kernel_addr_r 0x90000 0x400000
+setenv uenvcmd run loadprobe \&\& run loadkernel \&\& run loaddtb \&\& bootm $kernel_addr_r - $fdt_addr_r
+run uenvcmd
--- a/package/base-files/files/bin/config_generate	2021-04-19 22:10:14.000000000 +0300
+++ b/package/base-files/files/bin/config_generate	2021-05-08 21:04:39.783976932 +0300
@@ -4,6 +4,9 @@
 
 . /usr/share/libubox/jshn.sh
 
+board=$(cat /tmp/sysinfo/board_name)
+boardname="${board##*,}"
+
 [ -s $CFG ] || /bin/board_detect || exit 1
 [ -s /etc/config/network -a -s /etc/config/system ] && exit 0
 
@@ -140,7 +143,7 @@
 		static)
 			local ipad
 			case "$1" in
-				lan) ipad=${ipaddr:-"192.168.1.1"} ;;
+				lan) ipad=${ipaddr:-"192.168.10.1"} ;;
 				*) ipad=${ipaddr:-"192.168.$((addr_offset++)).1"} ;;
 			esac
 
@@ -280,8 +283,12 @@
 	uci -q batch <<-EOF
 		delete system.@system[0]
 		add system system
-		set system.@system[-1].hostname='OpenWrt'
-		set system.@system[-1].timezone='UTC'
+		set system.@system[-1].hostname=${boardname}
+		set system.@system[-1].timezone='EET-2EEST,M3.5.0/3,M10.5.0/4'
+		set system.@system[-1].zonename='Asia/Ho_Chi_Minh'
+		set system.@system[-1].log_proto='udp'
+		set system.@system[-1].conloglevel='8'
+		set system.@system[-1].cronloglevel='8'
 		set system.@system[-1].ttylogin='0'
 		set system.@system[-1].log_size='64'
 		set system.@system[-1].urandom_seed='0'
@@ -300,7 +307,7 @@
 		json_select system
 			local hostname
 			if json_get_var hostname hostname; then
-				uci -q set "system.@system[-1].hostname=$hostname"
+				uci -q set "system.@system[-1].hostname=$boardname"
 			fi
 
 			local compat_version
--- a/package/base-files/image-config.in	2021-04-19 22:10:14.000000000 +0300
+++ b/package/base-files/image-config.in	2021-05-08 21:04:39.783976932 +0300
@@ -76,7 +76,7 @@
 config TARGET_PREINIT_IP
 	string
 	prompt "IP address for preinit network messages" if PREINITOPT
-	default "192.168.1.1"
+	default "192.168.10.1"
 	help
 		IP address used to configure interface for preinit network
 		messages, including failsafe messages
@@ -92,7 +92,7 @@
 config TARGET_PREINIT_BROADCAST
 	string
 	prompt "Broadcast address for preinit network messages" if PREINITOPT
-	default "192.168.1.255"
+	default "192.168.10.255"
 	help
 		Broadcast address to which to send preinit network messages, as
 		as failsafe messages
--- a/package/base-files/Makefile	2021-04-19 22:10:14.000000000 +0300
+++ b/package/base-files/Makefile	2021-05-08 21:04:39.783976932 +0300
@@ -82,9 +82,9 @@
 	echo 'pi_init_cmd=$(if $(CONFIG_TARGET_INIT_CMD),$(CONFIG_TARGET_INIT_CMD),"/sbin/init")' >>$(1)/lib/preinit/00_preinit.conf
 	echo 'pi_init_suppress_stderr="$(CONFIG_TARGET_INIT_SUPPRESS_STDERR)"' >>$(1)/lib/preinit/00_preinit.conf
 	echo 'pi_ifname=$(if $(CONFIG_TARGET_PREINIT_IFNAME),$(CONFIG_TARGET_PREINIT_IFNAME),"")' >>$(1)/lib/preinit/00_preinit.conf
-	echo 'pi_ip=$(if $(CONFIG_TARGET_PREINIT_IP),$(CONFIG_TARGET_PREINIT_IP),"192.168.1.1")' >>$(1)/lib/preinit/00_preinit.conf
+	echo 'pi_ip=$(if $(CONFIG_TARGET_PREINIT_IP),$(CONFIG_TARGET_PREINIT_IP),"192.168.10.1")' >>$(1)/lib/preinit/00_preinit.conf
 	echo 'pi_netmask=$(if $(CONFIG_TARGET_PREINIT_NETMASK),$(CONFIG_TARGET_PREINIT_NETMASK),"255.255.255.0")' >>$(1)/lib/preinit/00_preinit.conf
-	echo 'pi_broadcast=$(if $(CONFIG_TARGET_PREINIT_BROADCAST),$(CONFIG_TARGET_PREINIT_BROADCAST),"192.168.1.255")' >>$(1)/lib/preinit/00_preinit.conf
+	echo 'pi_broadcast=$(if $(CONFIG_TARGET_PREINIT_BROADCAST),$(CONFIG_TARGET_PREINIT_BROADCAST),"192.168.10.255")' >>$(1)/lib/preinit/00_preinit.conf
 	echo 'pi_preinit_net_messages="$(CONFIG_TARGET_PREINIT_SHOW_NETMSG)"' >>$(1)/lib/preinit/00_preinit.conf
 	echo 'pi_preinit_no_failsafe_netmsg="$(CONFIG_TARGET_PREINIT_SUPPRESS_FAILSAFE_NETMSG)"' >>$(1)/lib/preinit/00_preinit.conf
 	echo 'pi_preinit_no_failsafe="$(CONFIG_TARGET_PREINIT_DISABLE_FAILSAFE)"' >>$(1)/lib/preinit/00_preinit.conf
--- a/feeds.conf.default	2021-04-19 22:10:14.000000000 +0300
+++ b/feeds.conf.default	2021-05-08 21:04:39.783976932 +0300
@@ -2,3 +2,4 @@
 src-git-full luci https://git.openwrt.org/project/luci.git^e98243ef9eb838cca80cdd6d1bd0cf69a509d103
 src-git-full routing https://git.openwrt.org/feed/routing.git^8071852b4556a02533cacb7a0f6a432df3507302
 src-git-full telephony https://git.openwrt.org/feed/telephony.git^920fbc5c0a2e4badf51bceff42e9a1e3eb693462
+src-git opicyberwrt https://github.com/melsem/opi-zero-cyberwrt.git
